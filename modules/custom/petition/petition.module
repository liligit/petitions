<?php

/**
 * @file
 * Provides a Petition content type.
 */

require_once 'includes/petition.inc';
require_once 'includes/petition.field.inc';
require_once 'includes/petition.mongo2mysql.inc';

// Apache Solr custom field names. Prefixes determine the storage mechanism,
// e.g., "bs_*" for boolean, single-valued and "sm_" is for string,
// multi-valued. See the dynamicField definitions in
// solr-conf/solr-3.x/schema.xml in the apachesolr module for a complete list.
define('PETITION_SOLR_FIELD_BODY', 'ts_body');
define('PETITION_SOLR_FIELD_TYPE_NAMES', 'sm_type_names');
define('PETITION_SOLR_FIELD_TYPE_TIDS', 'im_type_tids');
define('PETITION_SOLR_FIELD_ISSUE_NAMES', 'sm_issue_names');
define('PETITION_SOLR_FIELD_ISSUE_TIDS', 'im_issue_tids');
define('PETITION_SOLR_FIELD_LEGACY_ID', 'ss_legacy_id');
define('PETITION_SOLR_FIELD_LEGACY_PATH', 'ss_legacy_path');
define('PETITION_SOLR_FIELD_NODE_ID', 'entity_id');
define('PETITION_SOLR_FIELD_PATH', 'ss_path');
define('PETITION_SOLR_FIELD_PETITION_STATUS', 'is_petition_status');
define('PETITION_SOLR_FIELD_RESPONSE_ID', 'is_response_id');
define('PETITION_SOLR_FIELD_RESPONSE_STATUS', 'is_response_status');
define('PETITION_SOLR_FIELD_REVIEW_TIMEFRAME', 'is_review_timeframe');
define('PETITION_SOLR_FIELD_SIGNATURE_COUNT', 'is_signature_count');
define('PETITION_SOLR_FIELD_SIGNATURE_PUBLIC_THRESHOLD', 'is_signature_public_threshold');
define('PETITION_SOLR_FIELD_SIGNATURE_RESPONSE_THRESHOLD', 'is_signature_response_threshold');
define('PETITION_SOLR_FIELD_TIMESTAMP_CREATED', 'ds_created');
define('PETITION_SOLR_FIELD_TIMESTAMP_PUBLISHED', 'is_timestamp_published');
define('PETITION_SOLR_FIELD_TIMESTAMP_REACHED_PUBLIC', 'is_timestamp_reached_public');
define('PETITION_SOLR_FIELD_TIMESTAMP_RESPONSE_ASSOCIATED', 'is_timestamp_response_associated');
define('PETITION_SOLR_FIELD_TITLE', 'label');
define('PETITION_SOLR_FIELD_UID', 'is_uid');

/**
 * Implements hook_init().
 */
function petition_init() {
  global $conf;
  if (!shunt_is_enabled('petitions_solr_index')) {
    // Disable Solr indexing of petition nodes.
    if (isset($conf['apachesolr_environments'])) {
      foreach ($conf['apachesolr_environments'] as $env => $data) {
        if (!isset($conf['apachesolr_environments'][$env]['index_bundles']['node']) || !in_array('petition', $conf['apachesolr_environments'][$env]['index_bundles']['node'])) {
          $conf['apachesolr_environments'][$env]['index_bundles']['node'][] = 'petition';
        }
      }
    }
  }
  // Prevent anon user from visiting dashboard.
  if (in_array(drupal_get_path_alias(), variable_get('petition_paths_redirect_anon_to_home', array())) && !user_is_logged_in()) {
    drupal_goto('/');
  }
}

/**
 * Implements hook_menu().
 */
function petition_menu() {
  $items = array();
  $items['admin/petitions/settings/refresh'] = array(
    'title' => 'Petitions AJAX refresh',
    'description' => 'Configuration for the AJAX refreshing of petition data.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('petition_ajax_refresh_configuration'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
  );

  // Add a menu path for the user account edit page that does not require a
  // user id (and menu token) in the path.
  $items['user/edit'] = array(
    'title' => 'Edit user account',
    'page callback' => 'petition_user_edit_page',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Callback for the AJAX configuration administration page.
 */
function petition_ajax_refresh_configuration() {
  $form['petition_refresh_delay'] = array(
    '#type' => 'select',
    '#title' => t('Petition AJAX refresh delay'),
    '#options' => array(
      60 => t('1 minute'),
      120 => t('2 minutes'),
      180 => t('3 minutes'),
      240 => t('4 minutes'),
      300 => t('5 minutes'),
      600 => t('10 minutes'),
      900 => t('15 minutes'),
      1200 => t('20 minutes'),
      1800 => t('30 minutes'),
    ),
    '#default_value' => variable_get('petition_refresh_delay', 60),
    '#required' => TRUE,
  );
  $form['petition_ajax_refresh_endpoint'] = array(
    '#type' => 'textfield',
    '#title' => 'Petition AJAX refresh endpoint',
    '#default_value' => variable_get('petition_ajax_refresh_endpoint'),
    '#size' => 60,
    '#maxlength' => 128,
    '#required' => TRUE,
  );
  $form['popular_petitions_refresh_delay'] = array(
    '#type' => 'select',
    '#title' => t('Popular Petitions AJAX refresh delay'),
    '#options' => array(
      0 => t('Refresh Disabled'),
      60 => t('1 minute'),
      120 => t('2 minutes'),
      180 => t('3 minutes'),
      240 => t('4 minutes'),
      300 => t('5 minutes'),
      600 => t('10 minutes'),
      900 => t('15 minutes'),
      1200 => t('20 minutes'),
      1800 => t('30 minutes'),
    ),
    '#default_value' => variable_get('popular_petitions_refresh_delay', 0),
    '#required' => TRUE,
  );
  return system_settings_form($form);
}

/**
 * Implements hook_block_info().
 */
function petition_block_info() {
  $blocks = array();
  $blocks['signature_count'] = array(
    'info' => t('Signature count'),
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function petition_block_view($delta) {
  $block = array();
  switch ($delta) {
    case 'signature_count':
      $object = menu_get_object();
      if (!$object || $object->type != 'petition') {
        break;
      }
      $petition_item = PetitionsController::loadObject($object->nid);
      $is_error = !$petition_item;
      if ($is_error) {
        break;
      }
      else {
        $is_signable = $petition_item->isSignable();
      }
      $signatures = (int) $petition_item->getSignatureCount();
      $threshold = (int) $petition_item->getSignatureThreshold();
      $block['content'] = theme('signatures_progress_bar', array(
        'signatures' => $signatures,
        'goal' => $threshold,
        'clickable' => $is_signable,
      ));
      $block['content']['#attached']['css'] = array(
        drupal_get_path('module', 'petition') . '/css/signature_count.css',
      );
      if ($is_signable) {
        $block['content']['#prefix'] = '<h4 class="block__title">' . t('Sign This Petition') . '</h4>';

        $deadline = $petition_item->getDeadline();
        $deadline = date('F j, Y', $deadline);
        $message = array(
          '#markup' => '<p>' . t('Needs <span class="signatures-needed">!signatures</span> <span class="bold">signatures</span> by <span class="date">!date</span> to get a response from the White House</p>',
            array(
              '!signatures' => wh_petitions_format_number($petition_item->getSignaturesNeeded()),
              '!date' => $deadline,
            )),
        );

        array_unshift($block['content'], $message);
        $block['content']['#attached']['js'] = array(
          array(
            'data' => array(
              'petition' => array(
                'petition_id' => (int) $object->nid,
                'ajax_delay' => (int) variable_get('petition_refresh_delay', 60),
                'api_base' => variable_get('petition_ajax_refresh_endpoint'),
              ),
            ),
            'type' => 'setting',
          ),
          drupal_get_path('module', 'petition') . '/js/signature_count.js',
        );
      }
      else {
        $block_title = array(
          '#theme' => 'html_tag',
          '#tag' => 'h4',
          '#value' => t('Signature Count'),
          '#attributes' => array(
            'class' => array(
              'block__title',
            )
          )
        );
        $block['content']['#prefix'] = drupal_render($block_title);
      }
  }
  return $block;
}

/**
 * Implements hook_entity_view().
 */
function petition_node_view($node, $view_mode, $langcode) {
  if ($node->type == "petition" && $view_mode == "full") {
    $content = $node->content;

    // Evaluate the petition_context_condition_signable context.
    $plugin = context_get_plugin('condition', 'petition_context_condition_signable');
    if ($plugin) {
      $plugin->execute($node);
    }

    // Let's add the title before the body.
    $title = array("#markup" => "<h1>{$node->title}</h1>");
    $content = _petition_array_pre_insert("body", "title", $title, $content);

    // Let's add signatures needed before signature count.
    // The number of signatures still needed.
    $signature_deficit = 0;
    // The date for when the signature window closes.
    // @todo calculate the date  (date published) + (days to reach) - (today).
    $due_date = 'date not calculated yet';

    // @todo Looping logic and math to calculate signature_deficit is flawed.
    //   These should both be single values not needing loops.
    // @todo Verify that this display is supposed to use the count to response
    //   rather than the count to reach public. Or perhaps it is supposed to
    //   display both.
    $items = field_get_items("node", $node, "field_petition_response_sign");
    if ($items) {
      foreach ($items as $item) {
        $signature_deficit = (int) $item['value'];
      }
    }

    $signature_deficit -= (int) $node->signature_count;

    // Determine if it stilll needs signatures (has a positive deficit) or not.
    if ($signature_deficit > 0) {
      // Petition still needs more signatures.
      $signatures_needed = array(
        "#markup" =>
        "<div id='signatures_needed'><label>Signatures needed by {$due_date} </label><p>{$signature_deficit}</p></div>",
      );
    }
    else {
      // Petition has enough signatures.
      // @todo  signature goal message needs work.
      $signatures_needed = array(
        "#markup" =>
        "<div id='signatures_needed'><label><p>Achieved signature goal.</p></div>",
      );
    }

    $content = _petition_array_pre_insert("field_petition_signature_count",
            "signatures_needed", $signatures_needed, $content);

    $node->content = $content;
  }
}

/**
 * Implements hook_node_load().
 */
function petition_node_load($nodes, $types) {
  foreach ($nodes as $nid => $node) {
    if ($node->type == 'petition') {
      $signature_count = db_select('signature_mail', 'sm')
        ->condition('petition_id', $nid)
        ->countQuery()
        ->execute()
        ->fetchField();
      @$node->signature_count = $signature_count;
    }
  }
}

/**
 * Implements hook_apachesolr_index_document_build_ENTITY_TYPE().
 */
function petition_apachesolr_index_document_build_node(ApacheSolrDocument $document, $entity, $env_id) {
  if ($entity->type == 'petition') {
    $document->addField(PETITION_SOLR_FIELD_BODY, $entity->body[LANGUAGE_NONE][0]['safe_value']);

    $type_tids = array();
    foreach ($entity->field_petition_type[LANGUAGE_NONE] as $value) {
      $type_tids[] = $value['tid'];
    }
    $types = taxonomy_term_load_multiple($type_tids);
    foreach ($types as $term) {
      $document->addField(PETITION_SOLR_FIELD_TYPE_TIDS, (int) $term->tid);
      $document->addField(PETITION_SOLR_FIELD_TYPE_NAMES, $term->name);
    }

    $issue_tids = array();
    foreach ($entity->field_petition_issues[LANGUAGE_NONE] as $value) {
      $issue_tids[] = $value['tid'];
    }
    $issues = taxonomy_term_load_multiple($issue_tids);
    foreach ($issues as $term) {
      $document->addField(PETITION_SOLR_FIELD_ISSUE_TIDS, (int) $term->tid);
      $document->addField(PETITION_SOLR_FIELD_ISSUE_NAMES, $term->name);
    }

    $legacy_id = '';
    if (!empty($entity->field_legacy_id[LANGUAGE_NONE][0]['value'])) {
      $legacy_id = $entity->field_legacy_id[LANGUAGE_NONE][0]['value'];
    }
    $document->addField(PETITION_SOLR_FIELD_LEGACY_ID, $legacy_id);

    $document->addField(PETITION_SOLR_FIELD_PATH, drupal_get_path_alias("node/{$entity->nid}"));

    $legacy_path = '';
    if (!empty($entity->field_legacy_path[LANGUAGE_NONE][0]['value'])) {
      $legacy_path = $entity->field_legacy_path[LANGUAGE_NONE][0]['value'];
    }
    $document->addField(PETITION_SOLR_FIELD_LEGACY_PATH, $legacy_path);

    $document->addField(PETITION_SOLR_FIELD_PETITION_STATUS, (int) $entity->field_petition_status[LANGUAGE_NONE][0]['value']);

    if (!empty($entity->field_response_id[LANGUAGE_NONE][0]['target_id'])) {
      $response_id = $entity->field_response_id[LANGUAGE_NONE][0]['target_id'];
      $response = node_load($response_id);
      $document->addField(PETITION_SOLR_FIELD_RESPONSE_ID, (int) $response_id);
      $document->addField(PETITION_SOLR_FIELD_TIMESTAMP_RESPONSE_ASSOCIATED, (int) $response->created);
    }

    $document->addField(PETITION_SOLR_FIELD_RESPONSE_STATUS, (int) $entity->field_response_status[LANGUAGE_NONE][0]['value']);

    $document->addField(PETITION_SOLR_FIELD_REVIEW_TIMEFRAME, (int) $entity->field_petition_review_timeframe[LANGUAGE_NONE][0]['value']);

    $signature_count = 0;
    if (!empty($entity->signature_count)) {
      $signature_count = $entity->signature_count;
    }
    elseif (!empty($entity->field_petition_signature_count[LANGUAGE_NONE][0]['value'])) {
      $signature_count = $entity->field_petition_signature_count[LANGUAGE_NONE][0]['value'];
    }

    $document->addField(PETITION_SOLR_FIELD_SIGNATURE_COUNT, $signature_count);

    $document->addField(PETITION_SOLR_FIELD_SIGNATURE_PUBLIC_THRESHOLD, (int) $entity->field_petition_public_signatures[LANGUAGE_NONE][0]['value']);

    $document->addField(PETITION_SOLR_FIELD_SIGNATURE_RESPONSE_THRESHOLD, (int) $entity->field_petition_response_sign[LANGUAGE_NONE][0]['value']);

    if (!empty($entity->field_timestamp_published[LANGUAGE_NONE][0]['value'])) {
      $timestamp_published = $entity->field_timestamp_published[LANGUAGE_NONE][0]['value'];
      $document->addField(PETITION_SOLR_FIELD_TIMESTAMP_PUBLISHED, (int) $timestamp_published);
    }

    if (!empty($entity->field_timestamp_reached_public[LANGUAGE_NONE][0]['value'])) {
      $timestamp_reached_public = $entity->field_timestamp_reached_public[LANGUAGE_NONE][0]['value'];
      $document->addField(PETITION_SOLR_FIELD_TIMESTAMP_REACHED_PUBLIC, $timestamp_reached_public);
    }
  }
}

/**
 * Implements hook_entity_view_alter().
 */
function petition_entity_view_alter(&$build, $type) {
  if ($type == "node") {
    $node = $build['#node'];
    if ($node->type == "petition") {
      // Attempting to move the EVA signatures field to be displayed last
      // without luck.
      $build['signature_mail_listings_entity_view_1']['#weight'] = 10;
    }
  }
}

/**
 * Extracts the legacy IDs from a given set of petition IDs.
 *
 * @param array $petition_ids
 *   An array of petition IDs.
 *
 * @return array
 *   Returns an array of legacy IDs extracted from the given petition IDs.
 */
function petition_extract_legacy_ids_from_petition_ids(array $petition_ids) {
  $legacy_ids = array();
  foreach ($petition_ids as $id) {
    if (petition_is_legacy_id($id)) {
      $legacy_ids[] = $id;
    }
  }
  return $legacy_ids;
}

/**
 * Extracts the node IDs (nids) from a given set of petition IDs.
 *
 * @param array $petition_ids
 *   An array of petition IDs.
 *
 * @return array
 *   Returns an array of node IDs (nids) extracted from the given petition
 *   IDs.
 */
function petition_extract_nids_from_petition_ids(array $petition_ids) {
  $nids = array();
  foreach ($petition_ids as $id) {
    if (!petition_is_legacy_id($id)) {
      $nids[] = $id;
    }
  }
  return $nids;
}

/**
 * Implements hook_node_info().
 */
function petition_node_info() {
  $items = array(
    'petition' => array(
      'name' => t('Petition'),
      'base' => 'node_content',
      'description' => t('A petition can be created and upon receiving enough signatures can be eligible for display and gets set-up for response.'),
      'has_title' => '1',
      'title_label' => t('Title'),
      'help' => '',
    ),
  );
  return $items;
}

/**
 * Unpublish a single node from Drupal/MySql.
 *
 * @param array $node
 *   Actual node to update.
 */
function petition_hide($node) {
  $node->field_petition_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_STATUS_FLAGGED;
  node_save($node);

  $legacy_id = isset($node->field_legacy_id) ? $node->field_legacy_id['und'][0]['value'] : NULL;

  if (isset($legacy_id) && petitions_data_mongo_writes_are_enabled()) {
    wh_petitions_mongo2mysql_hide($legacy_id);
  }
}

/**
 * Publish a single node in Drupal/MySql.
 *
 * @param array $node
 *   Actual node to update.
 */
function petition_show($node) {
  $node->status = NODE_PUBLISHED;

  // @todo replace this unfortunate field_petition_status logic with a proper domain model.
  $timestamp_review = strtotime('- ' . $node->field_petition_review_timeframe[LANGUAGE_NONE][0]['value'] . ' days');
  $timestamp_published = $node->field_timestamp_published[LANGUAGE_NONE][0]['value'];
  $signature_count = $node->signature_count;
  $public_signatures = $node->field_petition_public_signatures[LANGUAGE_NONE][0]['value'];
  $response_signatures = $node->field_petition_response_sign[LANGUAGE_NONE][0]['value'];

  if ($timestamp_published < $timestamp_review) {
    $node->field_petition_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_STATUS_CLOSED;
  }
  elseif ($signature_count < $public_signatures) {
    $node->field_petition_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_STATUS_PRIVATE;
  }
  elseif ($signature_count < $response_signatures) {
    $node->field_petition_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_STATUS_PUBLIC;
  }
  elseif ($signature_count >= $response_signatures) {
    $node->field_petition_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_STATUS_UNDER_REVIEW;
    $node->field_response_status[LANGUAGE_NONE][0]['value'] = WH_PETITION_RESPONSE_STATUS_PENDING;
  }

  node_save($node);
  $legacy_id = isset($node->field_legacy_id) ? $node->field_legacy_id['und'][0]['value'] : NULL;

  if (isset($legacy_id) && petitions_data_mongo_writes_are_enabled()) {
    wh_petitions_mongo2mysql_show($legacy_id);
  }
}

/**
 * Check if petition has reached public or ready sig threshold.
 *
 * @param int $nid
 *   Petition node ID.
 */
function petition_check_reached_public_ready($nid) {
  $reached_response = FALSE;
  $node_changed = FALSE;
  $node = node_load($nid);
  $lang = $node->language;

  $signature_count = $node->signature_count;
  $petition_status = $node->field_petition_status[LANGUAGE_NONE][0]['value'];

  // # of signatures necessary to become a public petition.
  $public_signatures = $node->field_petition_public_signatures[LANGUAGE_NONE][0]['value'];

  // # of signatures necessary to become ready for a response.
  $response_signature_count = $node->field_petition_response_sign[LANGUAGE_NONE][0]['value'];

  $wrapper = entity_metadata_wrapper('node', $node);

  // Has not become public yet, check if has enough sigs now.
  if (!$wrapper->field_timestamp_reached_public->raw()) {
    // Record the time the petition became public.
    if ($petition_status == WH_PETITION_STATUS_PRIVATE && $signature_count >= $public_signatures) {
      $wrapper->field_petition_status->set((int) WH_PETITION_STATUS_PUBLIC);
      $wrapper->field_timestamp_reached_public->set((int) time());
      $node_changed = TRUE;
    }
  }
  // Has not reached ready for response yet, check if has enough sigs now.
  elseif (!$wrapper->field_timestamp_reached_ready->raw()) {
    // Record the time the petition became public.
    if ($petition_status == WH_PETITION_STATUS_PUBLIC && $signature_count >= $response_signature_count) {
      $wrapper->field_petition_status->set((int) WH_PETITION_STATUS_UNDER_REVIEW);
      $wrapper->field_response_status->set((int) WH_PETITION_RESPONSE_STATUS_PENDING);
      $wrapper->field_timestamp_reached_ready->set((int) time());
      $reached_response = TRUE;
      $node_changed = TRUE;
    }
  }

  if ($node_changed) {
    try {
      $wrapper->save();
    }
    catch (Exception $e) {
      logger_event('exceptions.petition.d7e3a0d');
      watchdog(
        'petition',
        'Unable to save petition node in petition_check_reached_public_ready for id :petitionid. Exception message: :message',
        array(
          ':petitionid' => $nid,
          ':message' => $e->getMessage(),
        ),
        WATCHDOG_ERROR
      );
    }

    // Email admin and the creator if the petition is ready for a response.
    if ($reached_response) {
      wh_petitions_email_ready_response((int) $node->nid, $node->uid);
      watchdog('wh_petitions', 'Petition (@id) Ready for Response Notification Sent.', array('@id' => $node->nid));
    }
  }
}

/**
 * Check if petition has crossed admin signature thresholds.
 *
 * @param int $nid
 *   Petition node ID.
 */
function petition_check_admin_thresholds($nid) {
  $node = node_load($nid);
  $lang = $node->language;

  $signature_count = $node->signature_count;
  // Not using entity_metadata_wrapper to avoid overhead if not public.
  $petition_status = $node->field_petition_status[LANGUAGE_NONE][0]['value'];

  $active_petition_thresholds = array(
    variable_get('wh_petitions_admin_signature_threshold_1', 25000) => array(
      'name' => 'wh_petitions_admin_signature_threshold_1',
      'field' => 'field_timestamp_rchd_sig_thresh1',
    ),
    variable_get('wh_petitions_admin_signature_threshold_2', 50000) => array(
      'name' => 'wh_petitions_admin_signature_threshold_2',
      'field' => 'field_timestamp_rchd_sig_thresh2',
    ),
    variable_get('wh_petitions_admin_signature_threshold_3', 75000) => array(
      'name' => 'wh_petitions_admin_signature_threshold_3',
      'field' => 'field_timestamp_rchd_sig_thresh3',
    ),
  );

  // Only check public petitions for thresholds.
  if ($petition_status == WH_PETITION_STATUS_PUBLIC) {
    $wrapper = entity_metadata_wrapper('node', $node);

    foreach ($active_petition_thresholds as $threshold_signatures => $threshold_data) {
      // Check if threshold field is empty or zero.
      if (!$wrapper->{$threshold_data['field']}->raw()) {
        // Threshold has not been met yet, no timestamp.
        if ($signature_count >= $threshold_signatures) {
          $wrapper->{$threshold_data['field']}->set((int) time());
          try {
            $wrapper->save();
          }
          catch (Exception $e) {
            logger_event('exceptions.petition.1fa4898');
            watchdog(
              'petition',
              'Unable to save petition node in petition_check_admin_thresholds for id :petitionid. Exception message: :message',
              array(
                ':petitionid' => $nid,
                ':message' => $e->getMessage(),
              ),
              WATCHDOG_ERROR
            );
          }

          // Send notification email for threshold crossed.
          wh_petitions_email_signature_threshold_crossed((int) $node->nid, $signature_count);
          logger_event('signatures_queue.workflow.process_signatures.notifications.' . $threshold_data['name'], 'set', (int) $node->nid);
        }
      }
    }
  }
}

/**
 * Determine if ID is a legacy mongo id.
 *
 * @param string $id
 *   Some id to test.
 *
 * @return bool
 *   True for success. False for fail.
 */
function petition_is_legacy_id($id) {
  // Assume it's not a legacy id unless it has some distinguising
  // characteristics of a legacy mongo id.
  // (Note: A more rigorous check would look in the db to see if the legacy id
  // exists. Let's avoid that for now just because it may be an unnecessary db
  // hit during high traffic events. Revisit if we need to make this more robust
  // later.)
  $is_legacy = FALSE;

  // Mongo IDs are: alpha numeric (not numeric) and 24 characters long.
  if (!is_numeric($id) && strlen($id) == 24) {
    $is_legacy = TRUE;
  }

  return $is_legacy;
}

/**
 * Determines whether a given path is a legacy path or not.
 *
 * @param string $path
 *   The path to test, without a leading forward slash (/).
 *
 * @return bool
 *   TRUE if the given path is a legacy path or FALSE if not.
 */
function petition_is_legacy_path($path) {
  $path_parts = explode('/', $path);

  // A legacy path has exactly three components.
  if (count($path_parts) !== 3) {
    return FALSE;
  }

  // The first component is the string "petition".
  if ($path_parts[0] !== 'petition') {
    return FALSE;
  }

  // The final component is a hash generated by wh_petitions_generate_hash().
  if (preg_match('/^[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ0123456789]{8}$/', $path_parts[2]) !== 1) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Wrapper around _petition_get_nid() for central exception handling.
 *
 * @param string $petition_id
 *   Legacy mongo-based petition id.
 *
 * @return int|false
 *   Returns node id for petition. 0 for not found. FALSE in case of error.
 */
function petition_get_nid($petition_id) {
  $nid = FALSE;

  try {
    $nid = _petition_get_nid($petition_id);
  }
  catch (Exception $e) {
    watchdog('petition', "Error getting petition NID. Exception: @exception", array(
      '@exception' => json_encode($e->getMessage()),
    ), WATCHDOG_ERROR);
  }

  return $nid;
}

/**
 * Look up node ID for a petition based on legacy id.
 *
 * @param string $petition_id
 *   Legacy mongo-based petition id.
 *
 * @return int|false
 *   Returns node id for petition. 0 for not found. FALSE in case of error.
 *
 * @throws Exception
 *   Throws an exception when the petition ID is neither a valid nid nor legacy
 *   ID.
 */
function _petition_get_nid($petition_id) {
  $nid = FALSE;

  if (petition_is_legacy_id($petition_id)) {
    $result = db_query("SELECT fli.entity_id FROM {field_data_field_legacy_id} fli WHERE fli.field_legacy_id_value = :legacy_id AND fli.entity_type = 'node' AND fli.bundle = 'petition'",
      array(':legacy_id' => $petition_id))->fetchObject();

    if ($result && isset($result->entity_id)) {
      $nid = $result->entity_id;
    }
  }
  elseif (intval($petition_id) == $petition_id && intval($petition_id) > 0) {
    // Assume if the nid is a positive integer it's a legit nid.
    $nid = $petition_id;
  }
  else {
    throw new Exception(t('This petition ID is neither a valid legacy mongo ID nor a valid node ID for a petition node: !petition_id',
      array('!petition_id' => $petition_id)
    ));
  }

  return $nid;
}

/**
 * Wrapper around _petition_get_legacy_id() for central exception handling.
 *
 * @param array $node
 *   Petition node.
 *
 * @return string|false
 *   Returns mongo id for petition. 0 for not found. FALSE in case of error.
 */
function petition_get_legacy_id($node) {
  $legacy_id = FALSE;

  try {
    $legacy_id = _petition_get_legacy_id($node);
  }
  catch (Exception $e) {
    watchdog('petition', "Error getting petition legacy ID. Exception: @exception", array(
      '@exception' => json_encode($e->getMessage()),
    ), WATCHDOG_ERROR);
  }

  return $legacy_id;
}

/**
 * Look up legacy ID for a petition node.
 *
 * @param array $node
 *   Petition node.
 *
 * @return string|false
 *   Returns mongo id for petition. 0 for not found. FALSE in case of error.
 *
 * @throws Exception
 *   Throws an exception when the petition is neither a node or a valid nid.
 */
function _petition_get_legacy_id($node) {
  $legacy_id = FALSE;

  if (is_numeric($node) || is_object($node)) {
    // Load the node if NID was provided.
    $node = (is_numeric($node) ? node_load($node) : $node);
  }
  else {
    throw new Exception(t('This petition ID is neither a valid node ID nor a node object: !petition',
      array('!petition' => $node)
    ));
  }
  $legacy_id = $node->field_legacy_id[$node->language][0]['value'];
  // Return '0' if legacy ID is null.
  $legacy_id = (!empty($legacy_id) ? $legacy_id : 0);

  return $legacy_id;
}

/**
 * Loads the number of unique signatures and IP addresses for a given petition.
 *
 * @param int $petition_id
 *   The ID of the petition.
 */
function petition_update_total_unique_ips_and_emails($petition_id) {
  $nid = petition_get_nid($petition_id);
  $email_count = db_select('petition_signature_emails')
    ->condition('petition_id', $nid)
    ->countQuery()
    ->execute()
    ->fetchField();

  $ip_count = db_select('petition_signature_ips')
    ->condition('petition_id', $nid)
    ->countQuery()
    ->execute()
    ->fetchField();

  $petition = node_load($nid);
  $wrapper = entity_metadata_wrapper('node', $petition);
  $wrapper->field_petition_sig_unq_email_act = (int) $email_count;
  $wrapper->field_petition_val_unq_ip_emails = (int) $ip_count;
  $wrapper->save();
}

/**
 * Stores an email in the database for use with fraud reporting metrics.
 *
 * @param string $petition_id
 *   The ID of the signed petition.
 * @param string $email
 *   The signature's email inbox. This should be an un-subaddressed value.
 *
 * @see disposable_email_unsubaddress_email
 */
function petition_add_signature_email($petition_id, $email) {
  $original_petition_id = $petition_id;
  $petition_id = petition_get_nid($petition_id);
  if (!$petition_id) {
    watchdog(
      'petition',
      'Invalid petition ID supplied while saving email :email. Petition ID: :petitionid',
      array(
        ':petitionid' => $original_petition_id,
        ':email' => $email,
      ),
      WATCHDOG_ERROR
    );
    return;
  }
  try {
    db_merge('petition_signature_emails')
      ->key(array(
        'email' => $email,
        'petition_id' => $petition_id,
      ))
      ->insertFields(array(
        'email' => $email,
        'petition_id' => $petition_id,
      ))
      ->expression('count', 'count + 1')
      ->execute();
  }
  catch (exception $e) {
    logger_event('exceptions.petition.220219a');
    watchdog(
      'petition',
      'Problem updating email count in petition :petitionid for email :email. Exception message: :message',
      array(
        ':petitionid' => $petition_id,
        ':email' => $email,
        ':message' => $e->getMessage(),
      ),
      WATCHDOG_ERROR
    );
  }
}

/**
 * Stores an IP address in the database for use with fraud reporting metrics.
 *
 * @param string $petition_id
 *   The ID of the signed petition.
 * @param string $ip
 *   The signature's IP address.
 */
function petition_add_signature_ip($petition_id, $ip) {
  if (empty($ip)) {
    return;
  }
  $original_petition_id = $petition_id;
  $petition_id = petition_get_nid($petition_id);
  if (!$petition_id) {
    watchdog(
      'petition',
      'Invalid petition ID supplied while saving IP :ip. Petition ID: :petitionid',
      array(
        ':petitionid' => $original_petition_id,
        ':ip' => $ip,
      ),
      WATCHDOG_ERROR
    );
    return;
  }
  try {
    db_merge('petition_signature_ips')
      ->key(array(
        'ip' => $ip,
        'petition_id' => $petition_id,
      ))
      ->insertFields(array(
        'ip' => $ip,
        'petition_id' => $petition_id,
      ))
      ->expression('count', 'count + 1')
      ->execute();
  }
  catch (exception $e) {
    logger_event('exceptions.petition.566b00e');
    watchdog(
      'petition',
      'Problem updating IP count in petition :petitionid for IP :ip. Exception message: :message',
      array(
        ':petitionid' => $petition_id,
        ':ip' => $ip,
        ':message' => $e->getMessage(),
      ),
      WATCHDOG_ERROR
    );
  }
}


/**
 * Removes a stored email used with fraud reporting metrics from the database.
 *
 * @param string $petition_id
 *   The ID of the signed petition.
 * @param string $email
 *   The signature's email inbox. This should be an un-subaddressed value.
 *
 * @see disposable_email_unsubaddress_email
 */
function petition_remove_signature_email($petition_id, $email) {
  try {
    db_update('petition_signature_emails')
      ->condition('petition_id', $petition_id)
      ->condition('email', $email)
      ->expression('count', 'count - 1')
      ->execute();
  }
  catch (exception $e) {
    watchdog('petition',
    'Problem removing email ":email" from petition :petition. Exception thrown: :exception',
    array(
      ':email' => $email,
      ':petition' => $petition_id,
      ':exception' => $e->getMessage(),
    ),
    WATCHDOG_WARNING);
  }
}

/**
 * Removes a stored IP address used with fraud reporting metrics from the database.
 *
 * @param string $petition_id
 *   The ID of the signed petition.
 * @param string $ip
 *   The signature's IP address.
 */
function petition_remove_signature_ip($petition_id, $ip) {
  try {
    db_update('petition_signature_ips')
      ->condition('petition_id', $petition_id)
      ->condition('ip', $ip)
      ->expression('count', 'count - 1')
      ->execute();
  }
  catch (exception $e) {
    watchdog('petition',
    'Problem removing IP address ":ip" from petition :petition.  Exception thrown: :exception',
    array(
      ':ip' => $ip,
      ':petition' => $petition_id,
      ':exception' => $e->getMessage(),
    ),
    WATCHDOG_WARNING);
  }
}

/**
 * Check if user exists by email address.
 *
 * @param string $email
 *   Email Address
 *
 * @return mixed
 *   User UID if exists, FALSE otherwise
 */
function petition_user_exists_by_mail($email) {
  $result = db_query("SELECT u.uid FROM {users} u WHERE mail = :mail", array(':mail' => $email))->fetchObject();
  if ($result) {
    return $result->uid;
  }
  return FALSE;
}

/**
 * Increments the counter on a petition metadata metric.
 *
 * @param int $petition_id
 *   The numeric petition ID.
 * @param string $metadata
 *   The metadata name.
 * @param mixed $value
 *   Value to set metadata field to, requires int or expression.
 */
function petition_set_metadata_value($petition_id, $metadata, $value) {
  try {
    db_merge('petition_metadata')
      ->key(array(
        'petition_id' => $petition_id,
        'metric' => $metadata,
      ))
      ->insertFields(array(
        'petition_id' => $petition_id,
        'metric' => $metadata,
      ))
      ->expression('value', $value)
      ->execute();
  }
  catch (exception $e) {
    logger_event('exceptions.petition.692ab33');
    watchdog(
      'petition',
      'Problem updating petition metadata metric :metric for petition :petitionid. Exception message: :message',
      array(
        ':petitionid' => $petition_id,
        ':metric' => $metadata,
        ':message' => $e->getMessage(),
      ),
      WATCHDOG_ERROR
    );
  }
}

/**
 * Increments the counter on a petition metadata metric.
 *
 * @param int $petition_id
 *   The numeric petition ID.
 * @param string $metadata
 *   The metadata name.
 * @param bool $decrement
 *   TRUE to decrease metadata instead of increase.
 */
function petition_increment_metadata($petition_id, $metadata, $decrement = FALSE) {
  $value = $decrement ? 'value - 1' : 'value + 1';
  petition_set_metadata_value($petition_id, $metadata, $value);
}

/**
 * Updates the values stored on petition nodes with the values from metadata.
 *
 * @param int $petition_id
 *   The node ID of the petition.
 * @param array $metrics
 *   An array of metric fields to update. Defaults to all metrics.
 */
function petition_update_metadata_counts($petition_id, $metrics = array()) {
  $fields_map = PetitionsSelectQueryMysql::getPetitionMetricFieldsMap();
  $metrics_to_update = array();
  $filtered_metrics = array();

  // Include all allowed metadata metrics.
  foreach ($fields_map as $metric => $field_map) {
    if ($field_map['include_in_metadata']) {
      $metrics_to_update[] = $metric;
    }
  }

  // If metrics have been passed in, filter them against allowed.
  if ($metrics) {
    foreach ($metrics_to_update as $metric) {
      if (in_array($metric, array_keys($metrics))) {
        $filtered_metrics[] = $metric;
      }
    }
    $metrics_to_update = $filtered_metrics;
  }

  if (empty($metrics_to_update)) {
    logger_event('exceptions.petition.b19abab');
    watchdog(
      'petition',
      'petition_update_metadata_counts metrics are empty or invalid for petition id :petitionid. Metrics: :metrics',
      array(
        ':petitionid' => $petition_id,
        ':metrics' => print_r($metrics, TRUE),
      ),
      WATCHDOG_ERROR
    );
    return;
  }

  $node = node_load($petition_id);
  if ($node->type != 'petition') {
    logger_event('exceptions.petition.e7235eb');
    watchdog(
      'petition',
      'petition_update_metadata_counts Type is not petition for id :petitionid, type is :type.',
      array(
        ':petitionid' => $petition_id,
        ':type' => $node->type,
      ),
      WATCHDOG_ERROR
    );
    return;
  }

  $wrapper = entity_metadata_wrapper('node', $node);
  foreach ($metrics_to_update as $metric) {
    $value = db_select('petition_metadata', 'pm')
      ->fields('pm', array('value'))
      ->condition('petition_id', $petition_id)
      ->condition('metric', $metric)
      ->execute()
      ->fetchField();
    if (empty($value) || $value === FALSE) {
      $value = 0;
    }
    $wrapper->$fields_map[$metric]['table'] = (int) $value;
  }
  $wrapper->save();
  logger_event('signatures_queue.metadata.petition_updated');
}

/**
 * Update field_petition_signature_count with count from signature_mail table.
 *
 * @param int $nid
 *   Petition node ID.
 */
function petition_update_petition_signature_count($nid) {
  $node = node_load($nid, NULL, TRUE);
  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->field_petition_signature_count->set($node->signature_count);
  $wrapper->save();
}
/**
 * Implements hook_petition_signatures_updated().
 */
function petition_petition_signatures_updated($nid) {
  // Leave petition_update_petition_signature_count 1st, it clears node cache.
  petition_update_petition_signature_count($nid);

  petition_check_reached_public_ready($nid);
  petition_check_admin_thresholds($nid);
  petition_update_metadata_counts($nid);
  petition_update_total_unique_ips_and_emails($nid);

  signatures_queue_compare_thresholds($nid);
}

/**
 * Implements hook_petition_status_updated().
 */
function petition_petition_status_updated($nid, $previous_status, $new_status) {
  if ($previous_status != WH_PETITION_STATUS_CLOSED && $new_status == WH_PETITION_STATUS_CLOSED) {
    // Force an update of metadata, ip/emails since petition has closed.
    petition_update_metadata_counts($nid);
    petition_update_total_unique_ips_and_emails($nid);
  }
}

/**
 * Update email and IP address fraud metrics metadata.
 *
 * @param int $petition_id
 *   Petition node ID.
 * @param string $email
 *   Email of signee (not un-subaddressed).
 * @param string $client_ip
 *   IP address of signee.
 */
function petition_update_email_ip_metrics($petition_id, $email, $client_ip) {
  // Store metrics for fraud reporting.
  $unsub_email = disposable_email_unsubaddress_email($email);
  petition_add_signature_email($petition_id, $unsub_email);
  petition_add_signature_ip($petition_id, $client_ip);

  $disposability = disposable_email_get_email_disposability($email);
  $disposability->is_free_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_FREE_EMAILS) : NULL;
  $disposability->is_open_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_OPEN_EMAILS) : NULL;
  $disposability->is_forwarding_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_FORWARDED_EMAILS) : NULL;
  $disposability->is_trash_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_TRASH_EMAILS) : NULL;
  $disposability->is_time_bound_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_TIMEBOUND_EMAILS) : NULL;
  $disposability->is_shredder_email ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_SHRED_EMAILS) : NULL;
  disposable_email_is_subaddressed_email($email) ? petition_increment_metadata($petition_id, PetitionItem::PETITION_SIGNATURE_COUNT_SUBADDRESSED_EMAILS) : NULL;
}

/**
 * Starts a reusable timer.
 *
 * This function is a mere wrapper for symmetry with
 * petition_reusable_timer_read_and_destroy(), which performs the important
 * work of preventing timers from accumulating through reuse.
 *
 * @param string $name
 *   The name of the timer.
 *
 * @see petition_reusable_timer_read_and_destroy()
 */
function petition_reusable_timer_start($name) {
  timer_start($name);
}

/**
 * Reads and destroys a reusable timer.
 *
 * Drupal provides no facility to destroying timers, so two uses of the same
 * timer name inside the same PHP process will accumulate, e.g., if a timer by
 * the same name is used inside a loop with five iterations and each iteration
 * takes one second, the first iteration will accurately register as having
 * taken one second, but the second will register as having taken two, the third
 * as three, etc.
 *
 * After calling this function, a timer by the same name can be safely started
 * using petition_reusable_timer_start().
 *
 * @param string $name
 *   The name of the timer.
 *
 * @return int
 *   The current timer value in milliseconds.
 *
 * @see petition_reusable_timer_start()
 */
function petition_reusable_timer_read_and_destroy($name) {
  $elapsed = (int) timer_read($name);

  // Delete the timer variable to prevent accumulation.
  unset($GLOBALS['timers'][$name]['start']);

  return $elapsed;
}

/**
 * Logs a database query to watchdog.
 *
 * @param string $type
 *   The category to which this message belongs. Can be any string, but the
 *   general practice is to use the name of the module calling
 *   petitionslog_log_query().
 * @param QueryAlterableInterface $query
 *   An Query object describing the composite parts of a SQL query.
 */
function petition_log_query($type, QueryAlterableInterface $query) {
  // Get the SQL for the query. This logic is adapted from devel's dpq(). The
  // chief difference is that the below doesn't invoke the query's preExecute()
  // method, which can cause errors in this context. Regardless, avoiding the
  // dependency makes it possible, if necessary, to use this feature in prod
  // without enabling devel there, and that's good thing.
  $sql = (string) $query;
  $quoted = array();
  $connection = Database::getConnection();
  foreach ((array) $query->arguments() as $key => $val) {
    $quoted[$key] = $connection->quote($val);
  }
  $sql = strtr($sql, $quoted);

  // Prefix tables so the string is directly copy/paste-able into an SQL tool.
  $sql = $connection->prefixTables($sql);

  // Run EXPLAIN. Wrap in a try..catch() in case of a database that doesn't
  // support the syntax.
  try {
    $result = db_query("EXPLAIN {$sql}");
    $explain = array();
    while ($row = $result->fetchAssoc()) {
      $explain[] = $row;
    }
  }
  catch (Exception $e) {
    $explain = t('Not available.');
  }

  watchdog($type, 'SQL: !sql EXPLAIN: !explain Query object: !query', array(
    '!sql' => petition_format_for_watchdog($sql),
    '!explain' => petition_format_for_watchdog($explain),
    '!query' => petition_format_for_watchdog($query),
  ));
}

/**
 * Formats data for logging via watchdog.
 *
 * @param mixed $data
 *   An arbitrary array or object to be formatted readably for logging.
 *
 * @return string
 *   The data formatted to send to watchdog.
 *
 * @see watchdog()
 */
function petition_format_for_watchdog($data) {
  return json_encode($data);
}

/**
 * Implements hook_theme().
 */
function petition_theme() {
  $items = array();

  $items['signatures_progress_bar'] = array(
    'render element' => 'element',
  );
  return $items;
}

/**
 * Generates a render array for the signature count progress bar.
 *
 * @param array $variables
 *   An array containing signatures and goal parameters.
 *
 * @return array
 *   A render array.
 */
function theme_signatures_progress_bar($variables) {
  $signatures = isset($variables['signatures']) ? $variables['signatures'] : 0;
  $goal = isset($variables['goal']) ? $variables['goal'] : 100000;
  $clickable = isset($variables['clickable']) ? $variables['clickable'] : FALSE;

  $signatures = (int) $signatures;
  $goal = (int) $goal;
  if ($signatures < $goal) {
    $percent = max(round($signatures / $goal * 100), 1);
  }
  else {
    $percent = 100;
  }

  $signatures = wh_petitions_format_number($signatures);
  $goal = wh_petitions_format_number($goal);
  $bar = array(
    'signature-container' => array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'signature-meter',
        ),
      ),
      'progress-bar' => array(
        '#theme' => 'html_tag',
        '#tag' => 'span',
        '#attributes' => array(
          'style' => array(
            'width: ' . $percent . '%',
          ),
        ),
      ),
    ),
    'signatures-text-container' => array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'signatures-text-container',
        ),
      ),
      'signature-count' => array(
        'signatures' => array(
          '#theme' => 'html_tag',
          '#tag' => 'span',
          '#value' => $signatures,
          '#attributes' => array(
            'class' => array(
              'signatures-number',
            ),
          ),
        ),
      ),
      'signatures-text' => array(
        '#theme' => 'html_tag',
        '#tag' => 'span',
        '#value' => t('signed'),
        '#attributes' => array(
          'class' => array(
            'signatures-text',
          ),
        ),
      ),
    ),
  );

  $signature_goal = array(
    'goal' => array(
      '#theme' => 'html_tag',
      '#tag' => 'span',
      '#value' => $goal,
      '#attributes' => array(
        'class' => array(
          'goal',
        ),
      ),
    ),
    'goal-text' => array(
      '#theme' => 'html_tag',
      '#tag' => 'span',
      '#value' => t('goal'),
      '#attributes' => array(
        'class' => array(
          'goal-text',
        ),
      ),
    ),
  );

  if ($clickable) {
    $signature_goal_container = array(
      'goal-text-container' => array(
        '#text' => render($signature_goal),
        '#theme' => 'link',
        '#path' => '/about',
        '#options' => array(
          'attributes' => array(
            'target' => '_blank',
            'class' => 'goal-text-container'
          ),
          'html' => TRUE,
        )
      )
    );
  }
  else {
    $signature_goal_container = array(
      'goal-text-container' => array(
        '#type' => 'container',
        '#attributes' => array(
          'class' => array(
            'goal-text-container',
          ),
        ),
      )
    );

    $signature_goal_container['goal-text-container'] += $signature_goal;
  }

  $bar = array_merge($bar, $signature_goal_container);
  return $bar;
}

/**
 * Implements hook_preprocess_node().
 */
function petition_preprocess_node(&$variables) {
  // Add the signatures progress bar for node teasers.
  $is_petition = $variables['node']->type == 'petition';
  $is_teaser = $variables['view_mode'] == 'teaser';
  if ($is_petition && $is_teaser) {
    $links = &$variables['content']['links']['node']['#links'];
    if (in_array($variables['field_petition_status'][LANGUAGE_NONE][0]['value'], wh_petitions_signable_statuses())) {
      $link_text = t('Sign It');
    }
    else {
      $link_text = t('View');
    }
    $links['node-readmore']['title'] = $link_text . "<span class=\"element-invisible\"> {$variables['node']->title}</span>";

    if ($threshold_field = field_get_items('node', $variables['node'], 'field_petition_response_sign')) {
      $signatures = $variables['node']->signature_count ? $variables['node']->signature_count : 0;
      $threshold = check_plain($threshold_field[0]['value']);
      $variables['content']['signature_progress_bar'] = theme('signatures_progress_bar', array('signatures' => $signatures, 'goal' => $threshold));
    };
  }
}

/**
 * Implements hook_context_plugins().
 */
function petition_context_plugins() {
  $plugins = array();
  $plugins['petition_context_condition_signable'] = array(
    'handler' => array(
      'path' => drupal_get_path('module', 'petition') . '/plugins/context',
      'file' => 'petition_context_condition_signable.inc',
      'class' => 'petition_context_condition_signable',
      'parent' => 'context_condition',
    ),
  );

  return $plugins;
}

/**
 * Implements hook_context_registry().
 */
function petition_context_registry() {
  return array(
    'conditions' => array(
      'petition_context_condition_signable' => array(
        'title' => t('Petition is Signable'),
        'description' => t('Uncheck to satisfy condition on a non-signable petition.'),
        'plugin' => 'petition_context_condition_signable',
      ),
    ),
  );
}

/**
 * Page callback to display the user account edit page.
 *
 * Redirects to user profile edit page if user is logged in, or the login form
 * for anonymous users.
 */
function petition_user_edit_page() {
  global $user;
  $uid = $user->uid;
  if ($uid) {
    drupal_goto('user/' . $uid . '/edit');
  }
  else {
    drupal_goto('user/login');
  }
}
