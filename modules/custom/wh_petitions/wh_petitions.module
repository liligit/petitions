<?php

/**
 * @file
 * Management and utility for petitions.
 *
 * WARNING: THIS MODULE IS GOING TO BE REMOVED BEFORE 7.x-3.0.
 */

// @todo Move legacy functions into here as they are flagged, renamed, or
// refactored throughout the code base.
require_once dirname(__FILE__) . '/wh_petitions.mongo2mysql.inc';

module_load_include('inc', 'wh_petitions', 'includes/wh_petitions.helper');

/**
 * @todo: Note: Trending used to be a link on the /petitions page.
 * This has been commented out, but the code is still here because we're
 * concerned about breaking something else by removing it. Please revisit.
 */

/* Petition Workflow
 *
 * -User clicks to continue after step 1 of the create a petition
 *  form - petition is saved as draft.
 *   -Petition can only be viewed by the creator in the create a petition
 *    form process and their dashboard
 * -User clicks to publish petition on step 4 of create a
 *  petition form - petition is published and made private.
 *   -Petition is only visible by direct url
 * -Petition retrieves X ( public_signatures ) signatures
 *  within X days ( review_timeframe ), is made public.
 *    -Petition is available in lists and by direct url
 * -Petition does not receive X ( public_signatures ) signatures
 *  within X days ( review_timeframe ) - is made closed
 *    -Petition is only available by direct url.
 * -Petition receives x ( review_signatures ) signatures
 *  within X days ( review_timeframe ) - is made under review
 *   -Can still receive signatures and appears in lists until
 *    responded to, even if that's past the number of days
 *    it had ( review_timeframe )
 * -Petition receives a response - changed to reviewed status.
 *   -Petition can no longer receive signatures and is removed from lists.
 *    Available by direct url and from the response page
 * -Petition receives X reports of abuse, made flagged status.
 *  Only available via direct url.
 */

/********************* DRUPAL HOOKS / BLOCKS ************************/

/**
 * Implements hook_perm().
 *
 * Creates three permissions:
 *  - administer permission settings: needed to access the
 *    admin/config/system/petitions page
 *  - adminster petitions: needed to access the admin/petitions
 *    page and perform actions such as bookmarking or
 *    featuring petitions.
 *  - create petition: needed to be able to create a petition.
 */
function wh_petitions_permission() {
  return array(
    'administer petition settings' => array(
      'title' => t('Administer petition settings'),
      'description' => t('Change petition and signature levels, administer block and page text.'),
    ),
    'administer petitions' => array(
      'title' => t('Administer petitions'),
      'description' => '',
    ),
    'create petition' => array(
      'title' => t('Create a petition'),
      'description' => '',
    ),
  );
}

/**
 * Implements modulename_preprocess().
 *
 * Insert variable into module template files.
 */
function wh_petitions_preprocess(&$variables, $hook) {
  global $base_url;
  $variables['path_to_petitions_responsive'] = $base_url . '/' . drupal_get_path('theme', 'petitions_responsive');
}

/**
 * Implements hook_menu().
 */
function wh_petitions_menu() {
  // Admin - Petition Tool Settings.
  $items['admin/petitions/settings/threshold_blocks'] = array(
    'title' => 'Petition Thresholds/Block Settings',
    'description' => 'Manage petition threshold settings and text.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petition_settings'),
    'access arguments' => array('administer petition settings'),
    'weight' => 10,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Admin - Petition Tool Email Settings.
  $items['admin/petitions/settings'] = array(
    'title' => 'Settings',
    'description' => 'Manage email notification templates users receive',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_admin_petition_email_settings'),
    'access arguments' => array('administer petition settings'),
    'weight' => 20,
    'file' => 'wh_petitions.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Admin - Petition Tool Email Settings.
  $items['admin/petitions/settings/user_emails'] = array(
    'title' => 'User Notification Emails',
    'description' => 'Manage petitions email notification templates users receive',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Admin - Petition Removal.
  $items['remove-mongo-petition'] = array(
    'title' => 'Petition Removal',
    'description' => 'Form to remove petitions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_removal_form'),
    'access arguments' => array('administer petitions'),
    'weight' => 10,
    'file' => 'wh_petitions_removal.inc',
    'type' => MENU_CALLBACK,
  );

  // Admin - AJAX callbacks.
  $items['admin/bookmark/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_bookmark_petitions',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/featured/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_feature_petitions',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/remove-lists/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_remove_lists',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );
  $items['admin/override-status/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_override_status',
    'page arguments' => array(2),
    'access arguments' => array('administer petitions'),
    'file' => 'wh_petitions.admin.inc',
  );

  // Autocomplete field for Petitions on the Apply Response form.
  $items['response-autocomplete'] = array(
    'page callback' => 'wh_petitions_response_autocomplete',
    'page arguments' => array(),
    'access arguments' => array('administer petitions'),
    'type' => MENU_CALLBACK,
    'file' => 'wh_petitions.admin.inc',
  );

  // Petition Detail page.
  $items['petition/detail/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_petition_detail',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  // Petition Detail for Nice URL.
  $items['petition/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_petition_detail_niceurl',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Email A Petition callbacks.
  $items['petition/email/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  $items['petition/email_frame/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition_frame',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );
  $items['petition/email_thank/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_email_petition_thank_you',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Create A Petition Form ( access control done in callback function ).
  $items['petition/create'] = array(
    'title' => 'Create a Petition',
    'description' => 'A menu link to create a petition.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wh_petitions_create_petition'),
    'access arguments' => array('access content'),
    'file' => 'includes/wh_petitions.create.form.inc',
    'type' => MENU_CALLBACK,
  );

  // More Petitions AJAX call.
  $items['petitions/more/%/%/%/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_more_petitions',
    'page arguments' => array(2, 3, 4, 5),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Report as Inappropriate modal AJAX call.
  $items['petition/inappropriate/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_inappropriate_modal',
    'page arguments' => array(2, 3),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Delete Petition callback.
  $items['petition/delete/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_delete_modal',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Delete Petition Page callback.
  $items['petition/deleted'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_deleted_page',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.pages.inc',
  );

  // Sign Petition AJAX call.
  $items['petition/sign/%'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_sign_modal',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Filter Issue Form Standalone Page
  // ( for compliance - they're in hidden divs that use JS normally )
  $items['filter-issues'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_issue_standalone',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Search Form Standalone Page
  // ( for compliance - they're in hidden divs that use JS normally )
  $items['filter-search'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_search_standalone',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  // Filter/Search results callback.
  $items['filter/results/petitions'] = array(
    'title' => '',
    'description' => '',
    'page callback' => 'wh_petitions_filter_results',
    'page arguments' => array(),
    'access arguments' => array('access content'),
    'file' => 'wh_petitions.form.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function wh_petitions_menu_alter(&$items) {
  $items['responses']['menu_name'] = 'petitions-menu';
  $items['responses']['weight'] = 30;

  $site_frontpage = variable_get('site_frontpage', FALSE);
  if ($site_frontpage == 'homepage') {
    $items['homepage']['menu_name'] = 'petitions-menu';
    $items['homepage']['weight'] = -1;
  }

  // Set access callback for node operations to our custom callback.
  $items['node/add/petition']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node/edit']['access callback'] = 'wh_petitions_petition_access';
  $items['node/%node/delete']['access callback'] = 'wh_petitions_petition_access';

  // @todo: Get rid of these if feeds module gets disabled or we actually start using it.
  if (module_exists('feeds')) {
    $items['node/%/log']['access callback'] = FALSE;
    $items['node/%/delete-items']['access callback'] = FALSE;
    $items['node/%/import']['access callback'] = FALSE;
    $items['node/%/unlock']['access callback'] = FALSE;
  }

  if (module_exists('devel')) {
    $items['node/%node/devel']['access callback'] = '_wh_petitions_user_access';
  }

}

/**
 * Implements hook_theme().
 */
function wh_petitions_theme() {
  return array(
    // Thank You Page after a user has published a petition.
    'wh_petitions_page_thank_you' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-thank-you',
    ),
    // Petition Detail Page.
    'wh_petitions_page_petition' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-petition',
    ),
    // Page a user sees after they delete a petition.
    'wh_petitions_page_deleted' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-deleted',
    ),
    // Generic archived petition page.
    'wh_petitions_page_archived' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-page-archived',
    ),
    // Signatures display on a petition detail page.
    'wh_petitions_display_signatures' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-signatures',
    ),
    // Petition info at the top of a petition page,
    // last page of create a petition.
    'wh_petitions_display_petition_info' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-petition-info',
    ),
    // List view display of a petition.
    'wh_petitions_display_list_petition' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-display-list-petition',
    ),
    // Header on Create A Petition section.
    'wh_petitions_create_header' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-create-header',
    ),
    // Renders the By The Numbers block body.
    'wh_petitions_by_the_numbers' => array(
      'arguments' => array(),
      'template' => 'templates/wh-petitions-by-the-numbers',
    ),
    // Displays the title field on the create a petition form.
    'wh_petition_title' => array(
      'render element' => 'element',
    ),
    // Generates the share_links for petitions pages.
    'petitions_share_links' => array(
      'variables' => array('title' => NULL, 'nid' => NULL, 'url' => NULL, 'short_url' => NULL),
      'render element' => 'share_links',
    ),
    // Generate the petition title preface.
    'petition_preface' => array(
      'variables' => array('node' => NULL),
    ),
    // Generate the petition attribution text.
    'petition_attribution' => array(
      'variables' => array('node' => NULL),
    ),
    'multicolumn_options' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_preprocess_node().
 *
 * Adds variables for the response node page, including the petitions that are associated with this node.
 */
function wh_petitions_preprocess_node(&$vars) {
  global $user;
  global $base_url;
  if ($vars['node']->type == 'petition') {
    $logged_in = ($user->uid > 0) ? TRUE : FALSE;

    $node = $vars['node'];
    $body_lang = ($node->language !== 'und') ? $node->language : LANGUAGE_NONE; 
    $lang = LANGUAGE_NONE;
    $nid = $node->nid;
    $petition_title = $node->title;
    $body = $node->body[$body_lang][0]['value'];
    $short_url = empty($node->field_short_url[$lang][0]['value']) ? '' : $node->field_short_url[$lang][0]['value'];
    // Set as published date, or FALSE if empty.
    if (empty($node->field_timestamp_published[$lang][0]['value'])) {
      $date_published = FALSE;
    }
    else {
      $date_published = $node->field_timestamp_published[$lang][0]['value'];
    }
    $review_timeframe_days = $node->field_petition_review_timeframe[$lang][0]['value'];
    $end_date = strtotime('+' . $review_timeframe_days . ' days', $date_published);
    $end_date = date("F d, Y", $end_date);
    $date_published = _wh_petitions_date_published($node);
    $total_needed = $node->field_petition_response_sign[$lang][0]['value'];
    $signatures_needed = $total_needed - $node->signature_count;

    // Initialize some variables we'll set later.
    $agency_name = '';
    $agency_seal = '';
    $response_title = '';
    $response_body = '';
    $response_audio = '';
    $response_video = '';
    $issues = '';
    $flagged = FALSE;
    $archived = FALSE;
    $responded = FALSE;
    $date_responded = FALSE;

    $path = drupal_get_path_alias('node/' . $nid);
    if ($signatures_needed < 0) {
      $signatures_needed = 0;
    }

    // Petition's Legacy ID,  or FALSE if empty.
    $legacy_id = (!empty($node->field_legacy_id[$node->language][0]['value']) ? $node->field_legacy_id[$node->language][0]['value'] : FALSE);

    $petition_id = !empty($legacy_id) ? $legacy_id : $nid;

    // Populate linked, comma separated 'Issues' variable.
    if (!empty($node->field_petition_issues[$node->language])) {
      $issues_array = $node->field_petition_issues[$node->language];
      $issues_count = count($issues_array);
      $first_issue = TRUE;
      $issues = array();
      foreach ($issues_array as $issue_array) {
        $term = taxonomy_term_load($issue_array['tid']);
        if (!empty($term)) {
          array_push($issues, l($term->name, 'petitions/all/0/2/' . intval($term->tid)));
        }
      }
      $issues = implode(", ", $issues);
    }

    // Petition status.
    $petition_status = $node->field_petition_status[$lang][0]['value'];

    // Set a flag for archived petitions
    if ($petition_status == WH_PETITION_STATUS_CLOSED) {
      $archived = TRUE;
    }
    // Petitions that have been reviewed and have a response attached ( should always be there together, but check just in case )
    elseif ($petition_status == WH_PETITION_STATUS_REVIEWED) {
      if ($node->field_response_status[$lang][0]['value'] == WH_PETITION_RESPONSE_STATUS_ANSWERED) {
        $responded = TRUE;

        // Get response details.  node_load might be a bit much in this case, but for now we'll stick with it.
        $response = node_load($node->field_response_id[$lang][0]['target_id']);
        if (!empty($response) && $response->status > 0) {
          $response_title = check_plain($response->title);
          $response_body = check_plain($response->body[$response->language][0]['value']);

          $agency_name = '';
          if (!empty($response->field_agency_name[$response->language][0]['value'])) {
            $agency_name = $response->field_agency_name[$response->language][0]['value'];
          }
          $agency_seal = '';
          if (!empty($response->field_agency_seal[$response->language][0]['uri'])) {
            $image_vars = array(
             'style_name' => 'agency_seal',
             'path' => $response->field_agency_seal[$response->language][0]['uri'],
             'alt' => (!empty($response->field_agency_seal[$response->language][0]['alt'])) ? check_plain($response->field_agency_seal[$response->language][0]['alt']) : '',
             'title' => (!empty($response->field_agency_seal[$response->language][0]['title'])) ? check_plain($response->field_agency_seal[$response->language][0]['title']) : '',
             'attributes' => array('class' => array('graphic')),
             'getsize' => TRUE,
            );
            $agency_seal = theme('image_style', $image_vars);
          }

          // Retrieve the appropiate audio/video field info for the response.
          if (!empty($response->field_response_media[$response->language][0])) {
            $media_tid = $response->field_response_media[$response->language][0]['tid'];
            $media = taxonomy_term_load($media_tid);
            $media_name = $media->name;

            switch ($media_name) {
              case 'Audio':
                if (!empty($response->field_audio_embed[$response->language][0])) {
                  $response_audio = check_plain($response->field_audio_embed[$response->language][0]['value']);
                }
                break;

              case 'Video':
                if (!empty($response->field_video_embed[$response->language][0])) {
                  $response_video = check_plain($response->field_video_embed[$response->language][0]['value']);
                }
                break;
            }
          }
          // Set date responded to as response created date.
          if (!empty($response->created)) {
            $date_responded = date('M d, Y', $response->created);
          }
        }
      }
    }
    // Petitions that have been flagged for review.
    elseif ($petition_status == WH_PETITION_STATUS_FLAGGED) {
      $flagged = TRUE;
    }

    // Admin Functionality
    $admin = FALSE;
    $admin_link = '';
    $reached_ready = '';
    if (user_access('administer petitions')) {
      $admin = TRUE;
      if (!empty($node->field_timestamp_reached_ready[$lang][0]['value'])) {
        $reached_ready = date('M d, Y', $node->field_timestamp_reached_ready[$lang][0]['value']);
      }

      $admin_link = petitionadmin_get_admin_link($node->nid);
    }

    $flagged_text = '';
    $flagged_text_owner = '';
    if ($flagged) {
      $flagged_text = variable_get('wh_petitions_flagged_page_text', '');
      if ($node->uid == $user->uid) {
        $flagged_text_owner = variable_get('wh_petitions_flagged_page_creator_text', '');
      }
    }
    $petition_goals_link = variable_get('wh_petitions_learn_more_link', '');

    // See if this user already signed the petition
    $already_signed = FALSE;
    if (!empty($user->uid)) {
      $signatures = SignaturesSelectQueryFactory::create()
      ->setPetitionId($petition_id)
      ->setUid($user->uid)
      ->execute()
      ->getResult();
      if (!empty($signatures[0]['id'])) {
        $already_signed = TRUE;
      }
    }
    // Show the signature form for petitions that haven't been signed by this user and are available to be signed.
    $why_text = '';
    $signature_form = '';

    // Set the 'Report as Inappropriate' link if it should appear.  Should appear on public/private/under review
    $reported_link = variable_get('wh_petitions_reported_as_inappropriate_link', '');
    $inappropriate_form = '';
    $has_reported = FALSE;
    $abuse_flag = array('target_id' => $user->uid);
    $is_flagged = (!empty($node->field_abuse_flags[$lang])) && is_array($node->field_abuse_flags[$lang]);
    if (in_array($petition_status, array(WH_PETITION_STATUS_DRAFT, WH_PETITION_STATUS_CLOSED, WH_PETITION_STATUS_REVIEWED, WH_PETITION_STATUS_FLAGGED)) || empty($user->uid)) {
      $inappropriate_link = FALSE;
    }
    elseif ($is_flagged && in_array($abuse_flag, $node->field_abuse_flags[$lang])) {
      $inappropriate_link = FALSE;
      $has_reported = TRUE;
    }
    else {
      $inappropriate_link = TRUE;
      module_load_include('inc', 'wh_petitions', 'wh_petitions.form');
      $inappropriate_form = drupal_get_form('wh_petitions_report_inappropriate_form', $petition_id);
      $inappropriate_form = drupal_render($inappropriate_form);
    }

    // Whether to include the share functionality.
    $has_share_bar = TRUE;
    if (in_array($petition_status, array(WH_PETITION_STATUS_DRAFT, WH_PETITION_STATUS_REVIEWED, WH_PETITION_STATUS_FLAGGED))) {
      $has_share_bar = FALSE;
    }

    // Call the share_links render array.
    $share_links = theme('petitions_share_links', array('node' => $node));
    $vars['content']['share_links'] = array(
      '#theme' => 'container',
      '#attributes' => array(
        'class' => array('petition-share-links'),
      ),
      '#children' => render($share_links),
    );

    module_load_include('inc', 'wh_petitions', 'wh_petitions.pages');

    $profile = profile2_load_by_user($user);
    $fields = array('first_name', 'last_name');
    $user_fields = array();
    foreach ($fields as $f) {
      if (!empty($profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'])) {
        $user_fields[$f] = $profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'];
      }
    }

    $first_initial = isset($user_fields['first_name']) ? strtoupper($user_fields['first_name'][0]) : '';
    $last_initial = isset($user_fields['last_name']) ? strtoupper($user_fields['last_name'][0]) : '';
    $creator_initials = $first_initial . '.' . $last_initial .'.';

    $return_destination = drupal_get_destination();
    $return_destination = preg_replace('/\?.*/', '', $return_destination);
    $vars['petition_title'] = check_plain($petition_title);
    $vars['body'] = wh_petitions_format_description($body);
    $vars['nid'] = $nid;
    $vars['petition_id'] = $petition_id;
    $vars['legacy_id'] = $legacy_id;
    $vars['short_url'] = $short_url;
    $vars['issues'] = $issues;
    $vars['date_published'] = $date_published;
    $vars['date_responded'] = $date_responded;
    $vars['flagged'] = $flagged;
    $vars['responded'] = $responded;
    $vars['archived'] = $archived;
    $vars['flagged_text'] = $flagged_text;
    $vars['flagged_text_owner'] = $flagged_text_owner;
    $vars['admin'] = $admin;
    $vars['admin_link'] = $admin_link;
    $vars['reached_ready'] = check_plain($reached_ready);
    $vars['end_date'] = check_plain($end_date);
    $vars['total_needed'] = wh_petitions_format_number($total_needed);
    $vars['signatures_needed'] = wh_petitions_format_number($signatures_needed);
    $vars['signature_count'] = wh_petitions_format_number($node->signature_count);
    $vars['signature_total'] = wh_petitions_format_number($node->signature_count);
    $vars['already_signed'] = $already_signed;
    $vars['signature_form'] = $signature_form;
    $vars['why_text'] = $why_text;
    $vars['inappropriate_form'] = $inappropriate_form;
    $vars['inappropriate_link'] = $inappropriate_link;
    $vars['has_reported'] = $has_reported;
    $vars['reported_link'] = $reported_link;
    $vars['petition_goals_link'] = $petition_goals_link;
    $vars['has_share_bar'] = $has_share_bar;
    $vars['logged_in'] = $logged_in;
    $vars['response_title'] = $response_title;
    $vars['response_body'] = $response_body;
    $vars['response_audio'] = $response_audio;
    $vars['response_video'] = $response_video;
    $vars['agency_name'] = $agency_name;
    $vars['agency_seal'] = $agency_seal;
    $vars['path_to_petitions_responsive'] = $base_url . '/' . drupal_get_path('theme', 'petitions_responsive');
    $vars['return_destination'] = $return_destination;

    // Call the share_links render array.
    $vars['share_links'] = theme('petitions_share_links', array('node' => $node));
    $vars['creator_initials'] = $creator_initials;
  }
}

/**
 * Implements hook_preprocess_HOOK()
 */
function wh_petitions_preprocess_page(&$vars) {
  // Remove title from Create Petition form page
  if (
      isset($vars['page']['content']['system_main']) &&
      isset($vars['page']['content']['system_main']['#form_id']) &&
      $vars['page']['content']['system_main']['#form_id'] == 'wh_petitions_create_petition'
  ) {
    drupal_set_title('');
  }

  // Add the creator attribution to the page $title_suffix.
  if (isset($vars['node']) && $vars['node']->type == 'petition') {
    $vars['title_suffix'] = theme('petition_attribution', array('node' => $vars['node']));
    $vars['title_prefix'] = theme('petition_preface', array('node' => $vars['node']));
  }
}

/**
 * Implements hook_preprocess_HOOK()
 */
function wh_petitions_preprocess_link(&$vars) {
  // Add destination parameter to login links.
  if ($vars['path'] == 'user/login') {
    if (empty($vars['options']['query']['destination'])) {
      $destination_path = drupal_get_path_alias();
      if (!empty($destination_path) && $destination_path != '/') {
        $vars['options']['query']['destination'] = $destination_path;
      }
    }
  }
}

/**
 * Implements hook_node_view()
 */
function wh_petitions_node_view($node, $view_mode, $langcode) {
  if ($node->type == 'petition') {
    $context = context_load('petition');
    context_set('context', 'petition', $context);
  }
}

/**
 * Implements hook_block_info().
 */
function wh_petitions_block_info() {
  $blocks['wh_petitions_by_numbers'] = array(
    'info' => 'By The Numbers',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_create_account'] = array(
    'info' => 'Create a WH Account',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_back_to_top'] = array(
    'info' => 'Back to top',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_email_signup'] = array(
    'info' => 'Email Signup',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_featured_petition'] = array(
    'info' => 'Helpful Hints',
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_helpful_hints'] = array(
    'info' => 'Helpful Hints',
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_history'] = array(
    'info' => 'History of Petitions',
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_recent_petitions'] = array(
    'info' => t('Recent Petitions'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );
  $blocks['wh_petitions_similar_petitions'] = array(
    'info' => t('Similar Petitions'),
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $blocks['wh_petitions_trending_petitions'] = array(
    'info' => t('Trending Petitions'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function wh_petitions_block_view($delta) {
  $block = array();

  switch ($delta) {
    // By The Numbers.
    case 'wh_petitions_by_numbers':
      $block['subject'] = t('By The Numbers');
      $block['content'] = wh_petitions_by_the_numbers();
      break;

    // Create A WH Account.
    case 'wh_petitions_create_account':
      $block['subject'] = t('Create a WH Account');
      $block['content'] = variable_get('wh_petitions_create_account_block_text', '');
      break;

    case 'wh_petitions_back_to_top':
      $block['subject'] = '';
      $block['content'] = '<span class="button hide" id="button-back-to-top">Back to top</span>';
      break;

    // Email Updates.
    case 'wh_petitions_email_signup':
      $block['subject'] = t('Sign Up For Email Updates');
      $block['content'] = variable_get('wh_petitions_email_updates_block_text', t('Sign Up for Updates from President Obama and Other Senior Officials.'));
      break;

    // History of Petitions.
    case 'wh_petitions_history':
      $block['subject'] = t('History of Petitions');
      $block['content'] = variable_get('wh_petitions_history_block_text', '');
      break;

    // Helpful Hints.
    case 'wh_petitions_helpful_hints':
      $block['subject'] = t('Helpful Hints');

      global $user;
      $content = '';
      if (arg(0) == 'petition' && arg(1) == 'create') {
        $content = variable_get('wh_petitions_hints_create_petition', '');
      }
      elseif (arg(0) == 'petitions') {
        $content = variable_get('wh_petitions_hints_open_petitions', '');
      }
      elseif (arg(0) == 'petition' && arg(1) == 'detail') {
        $content = variable_get('wh_petitions_hints_petition_detail', '');
      }
      elseif (arg(0) == 'responses') {
        $content = variable_get('wh_petitions_hints_responses', '');
      }
      elseif (arg(0) == 'response' && arg(1) == 'detail') {
        $content = variable_get('wh_petitions_hints_response_detail', '');
      }
      elseif (arg(0) == 'dashboard' && !empty($user->uid)) {
        $content = variable_get('wh_petitions_hints_dashboard', '');
      }
      else {
        $content = variable_get('wh_petitions_hints_misc', '');
      }

      $block['content'] = $content;
      break;

    // Recent Petitions.
    case 'wh_petitions_recent_petitions':
      $block['subject'] = t('Recent Petitions');

      $petitions_query = PetitionsSelectQueryFactory::create();
      $result = $petitions_query->setIsOpen(TRUE)
        ->setOrderBy(PetitionsSelectQuery::SELECT_QUERY_ORDER_BY_FIELD_DATE_REACHED_PUBLIC, PetitionsSelectQuery::SELECT_QUERY_ORDER_BY_DESC)
        ->setLimit(3)
        ->execute()
        ->getResult();

      $html = '';
      if (!empty($result)) {
        $html = '<ul>';
        foreach ($result as $res) {
          $html .= '<li>' . l($res['title'], $res['url']) . '</li>';
        }
        $html .= '</ul>';
      }
      $block['content'] = $html;
      break;

    // Similar Petitions.
    case 'wh_petitions_similar_petitions':
      $block['subject'] = t('Similar Petitions');

      // Only should display content on a petition detail page.
      if ((arg(0) == 'petition')) {
        if (petitions_data_mongo_reads_are_enabled()) {
          $conn = wh_petitions_mongo_petition_connection();
          $petition_id = wh_petitions_get_petition_id($conn);
          $block['content'] = wh_petitions_similar_petitions($conn, $petition_id);
        }
        else {
          $petition_id = wh_petitions_get_petition_id_by_url('petition/' . arg(1));
          $conn = NULL;
          $block['content'] = wh_petitions_similar_petitions($conn, $petition_id);
        }
      }
      else {
        $block['content'] = '';
      }
      break;

    // Trending Petitions.
    case 'wh_petitions_trending_petitions':
      module_load_include('inc', 'wh_petitions', 'wh_petitions.pages');
      $block['subject'] = t('Trending Petitions');
      $html = '';
      $total = 0;

      if (petitions_data_mongo_reads_are_enabled()) {
        // Get 3 most trending petitions.
        $conn = wh_petitions_mongo_petition_connection();
      }
      else {
        $conn = NULL;
      }

      $result = wh_petitions_trending_results($conn, 0, 3, $total);

      $html = '<ul>';
      foreach ($result as $res) {
        $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
      }
      $html .= '</ul>';

      $block['content'] = $html;
      break;
  }

  return $block;
}

/**
 * Implements hook_info().
 */
function wh_petitions_hook_info() {
  $hooks = array();
  $hooks['wh_petitions_signature_save'] = array(
    'group' => 'petitions',
  );
  return $hooks;
}

/**
 * Check a petition node for review threshold main sent.
 * @param $nid
 *   Petition Node ID.
 * @param bool $send_email
 *   If set to FALSE, will not send email - will only update sent flag.
 */
function _wh_petitions_compliance_review_threshold_check_node($nid, $send_email = TRUE) {
  $node = node_load($nid);
  $emails_to = variable_get('wh_petitions_compliance_reviewer_emails', FALSE);
  $threshold = (int) variable_get('wh_petitions_compliance_review_threshold', FALSE);
  $email_sent = isset($node->field_review_threshold_mail_sent) ? (int) $node->field_review_threshold_mail_sent[LANGUAGE_NONE][0]['value'] : 0;
  $petition_status = (int) $node->field_petition_status[LANGUAGE_NONE][0]['value'];

  // Check if no email has been sent, sig count above threshold, is signable.
  // Since petition can become Under Review prior, wh_petitions_signable_statuses is ok.
  if (!$email_sent && ($node->signature_count >= $threshold) && in_array($petition_status, wh_petitions_signable_statuses())) {
    try {
      if ($send_email) {
        drupal_mail('wh_petitions', 'review_threshold_passed', $emails_to, language_default(),
          array(
            'petition' => (array) $node,
          )
        );
      }

      // Save only field_review_threshold_mail_sent value so we don't clobber any multithread node updates.
      $node = new stdClass();
      $node->nid = $nid;
      $node->type = 'petition';
      $node->field_review_threshold_mail_sent[LANGUAGE_NONE][0]['value'] = time();
      field_attach_update('node', $node);
      field_attach_presave('node', $node);
      // Clear the static loading cache.
      entity_get_controller('node')->resetCache(array($node->nid));
    }
    catch (Exception $e) {
      watchdog('wh_petitions', 'Error sending compliance review threshold email for petition (@id). Exception: @exception', array(
        '@id' => $nid,
        '@exception' => petition_format_for_watchdog($e),

      ), WATCHDOG_ERROR);
    }
  }
}

/**
 * Pulls a list of petitions with more signatures than the compliance review
 * threshold and which have not been sent compliance review notifications.
 *
 * @param bool $send_email
 *   If set to FALSE, will not send emails - will only update sent flag.
 *
 * @return int
 *   Count of petitions meeting criteria for compliance review.
 */
function _wh_petitions_compliance_review_threshold_check($send_email = TRUE) {
  $threshold = (int) variable_get('wh_petitions_compliance_review_threshold', FALSE);
  $sub_query = db_or();
  $sub_query->isNull('review_threshold_mail_sent.field_review_threshold_mail_sent_value');
  $sub_query->condition('review_threshold_mail_sent.field_review_threshold_mail_sent_value', 0, '=');

  $query = db_select('node', 'n');
  $query->leftJoin('field_data_field_petition_signature_count', 'petition_signature_count', 'petition_signature_count.entity_id = n.nid');
  $query->leftJoin('field_data_field_review_threshold_mail_sent', 'review_threshold_mail_sent', 'review_threshold_mail_sent.entity_id = n.nid');
  $query->leftJoin('field_data_field_petition_status', 'petition_status', 'petition_status.entity_id = n.nid');

  $query->addField('n', 'nid', 'nid');
  $query->addField('petition_signature_count', 'field_petition_signature_count_value', 'signature_count');

  $query->condition('petition_signature_count.field_petition_signature_count_value', $threshold, '>=');
  $query->condition($sub_query);
  $query->condition('petition_status.field_petition_status_value', wh_petitions_signable_statuses(), 'IN');

  $notification_list = $query->execute()->fetchAllAssoc('nid');

  if ($notification_list) {
    foreach ($notification_list as $notification_nid => $notification) {
      _wh_petitions_compliance_review_threshold_check_node($notification_nid, $send_email);
    }
  }
  return count($notification_list);
}

/**
 * By The Numbers block body.
 */
function wh_petitions_by_the_numbers() {
  $numbers = array();
  if (petitions_data_mongo_reads_are_enabled()) {
    $conn = wh_petitions_mongo_petition_connection();

    // Total Petitions that are open.
    if (variable_get('wh_petitions_numbers_open_petitions', FALSE)) {
      $query = array(
        'petition_status' => array(
          '$in' => array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW),
        ),
        'hidden' => 0,
      );
      $total = $conn->find($query)->count();
      array_push($numbers, array('key' => t('Open Petitions'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Total Responses that are published.
    if (variable_get('wh_petitions_numbers_responses', FALSE)) {
      $query = db_select('node', 'n', array('target' => 'slave'));
      $query->fields('n', array('nid'))
        ->condition('n.type', 'wh_response')
        ->condition('n.status', 0, '<>');
      $total = $query->countQuery()->execute()->fetchField();
      array_push($numbers, array('key' => t('Total Responses'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Signatures in Past 24 Hours.
    if (variable_get('wh_petitions_numbers_signatures_24', FALSE)) {
      $sig_conn = wh_petitions_mongo_petition_signatures_connection();
      $timestamp = strtotime("-1 day");
      $query = array(
        'timestamp' => array('$gt' => (int) $timestamp),
      );
      $total = $sig_conn->find($query)->count();
      array_push($numbers, array('key' => t('Signatures in Past 24 Hours'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
  }
  else {
    // Total Petitions that are open.
    if (variable_get('wh_petitions_numbers_open_petitions', FALSE)) {

      $query = db_select('node', 'n');
      $query->leftJoin('field_data_field_petition_status', 'ps', 'ps.entity_id = n.nid');
      $query->addExpression('count(n.nid)', 'total');
      $query->condition('n.type', 'petition', '=');
      $query->condition('ps.field_petition_status_value', array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW), 'IN');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Open Petitions'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Total Responses that are published.
    if (variable_get('wh_petitions_numbers_responses', FALSE)) {

      $query = db_select('node', 'n');
      $query->fields('n', array('nid'));
      $query->condition('n.type', 'wh_response');
      $query->condition('n.status', 0, '<>');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Total Responses'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
    // Signatures in Past 24 Hours.
    if (variable_get('wh_petitions_numbers_signatures_24', FALSE)) {

      $query = db_select('signature_mail', 'sm');
      $query->addField('sm', 'id');
      $query->addfield('sm', 'timestamp');
      $query->condition('sm.timestamp', strtotime("-1 day"), '>');

      $total = $query->countQuery()->execute()->fetchField();

      array_push($numbers, array('key' => t('Signatures in Past 24 Hours'), 'value' => check_plain(wh_petitions_format_number($total))));
    }
  }
  return theme('wh_petitions_by_the_numbers', array('numbers' => $numbers));
}

/**
 * Similar Petitions block body.
 */
function wh_petitions_similar_petitions(&$conn, $petition_id) {

  $html = '';

  if (petitions_data_mongo_reads_are_enabled()) {
    $petition = wh_petitions_load_slim_petition($conn, $petition_id, array('issues', 'title_keywords'));
    if (empty($petition)) {
      return '';
    }

    // Get the issues into an array of keys.
    $issues = array();
    foreach ($petition['issues'] as $key => $val) {
      if ($val > 0) {
        array_push($issues, intval($val));
      }
    }

    // Removed common words from the string of title keywords.
    $title_keywords = $petition['title_keywords'];
    $title_terms = array();

    $search_terms = array(
      "and",
      "in",
      "this",
      "or",
      "a",
      "the",
      "an",
      "as",
      "at",
      "but",
      "by",
      "before",
      "for",
      "from",
      "is",
      "like",
      "of",
      "on",
      "onto",
      "than",
      "this",
      "that",
      "to",
      "with",
    );
    foreach ($title_keywords as $term) {
      if (!in_array($term, $search_terms)) {
        array_push($title_terms, $term);
      }
    }

    // Retrive the top 3 results sorted by signature
    // count DESC that match all the issues and at least
    // one of the title words and are not the current petition.
    $similar = '';
    $count = 0;
    $query = array(
      'petition_status' => array(
        '$in' => array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW),
      ),
      'hidden' => 0,
      'issues' => array('$in' => $issues),
      'title_keywords' => array('$in' => $title_terms),
      '_id' => array('$ne' => $petition['_id']),
    );
    $result = $conn->find($query, array('title', 'nice_url'))->sort(array('signature_count' => -1))->limit(3);

    $html = '';
    foreach ($result as $res) {
      if (empty($html)) {
        $html = '<ul>';
      }
      $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
    }
    if (!empty($html)) {
      $html .= '</ul>';
    }
  }
  else {

    if (!is_numeric($petition_id)) {
      $petition_id = petition_get_nid($petition_id);
    }
    $petition = node_load($petition_id);
    if (empty($petition)) {
      return '';
    }

    // Get the issues into an array of keys.
    $issues = array();
    foreach ($petition->field_petition_issues[$petition->language] as $key => $val) {
      if ($val['tid'] > 0) {
        array_push($issues, intval($val['tid']));
      }
    }

    // Removed common words from the string of title keywords.
    $title_keywords = $petition->title;
    $title_terms = array();

    $search_terms = array(
      "and",
      "in",
      "this",
      "or",
      "a",
      "the",
      "an",
      "as",
      "at",
      "but",
      "by",
      "before",
      "for",
      "from",
      "is",
      "like",
      "of",
      "on",
      "onto",
      "than",
      "this",
      "that",
      "to",
      "with",
    );
    foreach ($title_keywords as $term) {
      if (!in_array($term, $search_terms)) {
        array_push($title_terms, $term);
      }
    }

    // Retrive the top 3 results sorted by signature
    // count DESC that match all the issues and at least
    // one of the title words and are not the current petition.
    $similar = '';
    $count = 0;

    $query = db_select('node', 'n');
    $query->leftJoin('field_data_field_petition_status', 'ps', 'ps.entity_id = n.nid');
    $query->leftJoin('field_data_field_petition_issues', 'pi', 'pi.entity_id = n.nid');
    $query->leftJoin('url_alias', 'ua', 'substring(ua.source, 6) = n.nid');
    $query->leftJoin('field_data_field_petition_signature_count', 'sc', 'cs.entity_id = n.nid');

    $query->addField('n', 'nid');
    $query->addField('n', 'title');
    $query->addField('ua', 'alias', 'nice_url');

    $query->condition('n.type', 'petition', '=');
    $query->condition('ps.field_petition_status_value', array((int) WH_PETITION_STATUS_PUBLIC, (int) WH_PETITION_STATUS_UNDER_REVIEW), 'IN');
    $query->condition('pi.field_issues_tid', $issues, 'IN');
    $query->condition('n.title', $title_keywords, 'IN');

    $query->orderBy('field_data_field_petition_signature_count.field_petition_signature_count_value', 'DESC');
    $query->range(0, 3);

    $result = $query->execute()->fetchAllAssoc('nid');

    $html = '';
    foreach ($result as $res) {
      if (empty($html)) {
        $html = '<ul>';
      }
      $html .= '<li>' . l($res['title'], $res['nice_url']) . '</li>';
    }
    if (!empty($html)) {
      $html .= '</ul>';
    }
  }

  return $html;
}

/**
 * Implements hook_cron().
 *
 * Include the function to close any open petitions that
 * have exceeded the limit for amount of days to be open.
 * Also run the function to update the counts of how many petitions/responses
 * are related to each issue term.
 */
function wh_petitions_cron() {
  module_load_include('inc', 'wh_petitions', 'wh_petitions.cron');
  wh_petitions_close_petitions();
  wh_petitions_update_issue_counts();
}


/**
 * Emails the creator of a petition when their petition is published.
 */
function wh_petitions_email_published($petition_id, $uid) {
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      $params = array('petition_id' => $petition_id);
      $from = variable_get('wh_petitions_email_address', '');
      drupal_mail('wh_petitions', 'published', $email, language_default(), $params, $from);
    }
  }
}

/**
 * Email user when their petition is under review.
 *
 * Emails the creator of a petition when their petition
 * becomes under review ( enough signatures to receive a response )
 */
function wh_petitions_email_ready_response($petition_id, $uid) {
  $params = array('petition_id' => $petition_id);
  $from = variable_get('wh_petitions_email_address', '');

  // Enable this block of code to send ready_response emails to user.
  /*
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      drupal_mail('wh_petitions', 'ready_response', $email, language_default(), $params, $from);
    }
  }
  */

  // Email admins.
    $emails = variable_get('wh_petitions_admin_ready_response_emails', FALSE);
    drupal_mail('wh_petitions', 'admin_ready_response', $emails, language_default(), $params, $from);
}

/**
 * Email user when their petitions have been responded to.
 *
 * Emails the creator of a petition when their petition
 * receives a response. Currently not active.
 */
function wh_petitions_email_receive_response($petition_id, $uid) {
  if (!empty($uid)) {
    $user_load = user_load($uid);

    if (!empty($user_load)) {
      $email = $user_load->mail;
      $params = array();
      $from = variable_get('wh_petitions_email_address', '');
    }
  }
}

/**
 * Email admin when a petition crosses signature threshold.
 *
 * @param int $petition_id
 *   Petition ID
 * @param $signature_threshold_crossed
 *   Number of signatures crossed.
 */
function wh_petitions_email_signature_threshold_crossed($petition_id, $signature_threshold_crossed) {
  $params = array(
    'petition_id' => $petition_id,
    'signature_threshold_crossed' => $signature_threshold_crossed,
    );
  $from = variable_get('wh_petitions_email_address', '');

  // Email admins.
  $emails = variable_get('wh_petitions_admin_signature_threshold_crossed_emails', FALSE);
  drupal_mail('wh_petitions', 'admin_signature_threshold_crossed', $emails, language_default(), $params, $from);
}

/**
 * Implements hook_mail().
 *
 * Implements the email messages for when a petition is
 * published, is ready for a response and receives a response.
 */
function wh_petitions_mail($key, &$message, $params) {
  global $base_url;
  $options['language'] = $message['language'];
  $legacy_id = "";
  $replacements = array();

  if (in_array($key, array('ready_response', 'admin_ready_response', 'receive_response', 'admin_signature_threshold_crossed'))) {
    switch($key) {
      case 'ready_response':
        $message['subject'] = variable_get('wh_petitions_email_ready_response_subject', '');
        $message['body'] = array(variable_get('wh_petitions_email_ready_response_text', ''));
        break;

      case 'admin_ready_response':
        $message['subject'] = variable_get('wh_petitions_email_admin_ready_response_subject', '');
        $message['body'] = array(variable_get('wh_petitions_email_admin_ready_response_text', ''));
        break;

      case 'receive_response':
        $message['subject'] = variable_get('wh_petitions_email_receive_response_subject', '');
        $message['body'] = array(variable_get('wh_petitions_email_receive_response_text', ''));
        break;

      case 'admin_signature_threshold_crossed':
        $message['subject'] = variable_get('wh_petitions_email_admin_signature_threshold_crossed_subject', '');
        $message['body'] = array(variable_get('wh_petitions_email_admin_signature_threshold_crossed_text', ''));
        $replacements['!signature_threshold_crossed'] = $params['signature_threshold_crossed'];
      break;

      default:
        watchdog('wh_petitions', 'wh_petitions_mail - No case for @key key', array('@key' => $key));
        return FALSE;
    }

    $petition = PetitionsController::loadObject($params['petition_id']);
    if (!empty($petition)) {
      $short_url = ($petition->getShortUrl() != '') ? $petition->getShortUrl() : $petition->getNiceUrl();
      $replacements = array_merge($replacements, array(
        '!petition_edit_link' => variable_get('petitions_edit_url', $base_url) . '/node/' . $petition->getEntityId() . '/edit',
        '!petition_title' => check_plain($petition->getTitle()),
        '!petition_body' => check_plain($petition->getBody()),
        '!shorturl' => check_plain($short_url),
      ));

      $message['subject'] = format_string($message['subject'], $replacements);
      $message['body'][0] = format_string($message['body'][0], $replacements);
    }
    else {
      watchdog('wh_petitions', 'wh_petitions_mail - failed to load petition @petition_id', array('@petition_id' => $params['petition_id']));
      unset($message);
      return FALSE;
    }
    return TRUE;
  }

  // @todo This is a poorly written block of code, needs to be redone more like above.
  switch ($key) {
    case 'published':
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_email_published_subject', '');
      $message['body'][] = variable_get('wh_petitions_email_published_text', '');
      $legacy_id = $params['petition_id'];

      $petition = PetitionsController::loadObject($legacy_id);

      if (!empty($petition)) {

        // In case the short URL isn't available, use the absolute form of the
        // nice URL to use in emails, so that there's at least *something* to
        // click on.
        $short_url = ($petition->getShortUrl() != '') ? $petition->getShortUrl() : $petition->getNiceUrl();

        $end_date = strtotime('+' . $petition->getReviewTimeframe() . ' days', $petition->getPublished());
        $end_date = date("F d, Y", $end_date);
        $message['subject'] = str_replace('!shorturl', $short_url, $message['subject']);
        $message['subject'] = str_replace('!petition_title', $petition->getTitle(), $message['subject']);
        $message['body'][0] = str_replace('!petition_description', check_plain($petition->getBody()), $message['body'][0]);
        $message['body'][0] = str_replace('!shorturl', check_plain($short_url), $message['body'][0]);
        $message['body'][0] = str_replace('!petition_title', check_plain($petition->getTitle()), $message['body'][0]);
        $message['body'][0] = str_replace('!signatures_needed', wh_petitions_format_number($petition->getSignaturesNeeded()), $message['body'][0]);
        $message['body'][0] = str_replace('!public_signatures', wh_petitions_format_number($petition->getSignaturePublicThreshold()), $message['body'][0]);
        $message['body'][0] = str_replace('!date_needed', $end_date, $message['body'][0]);
        $message['body'][0] = str_replace('!day_timeframe', wh_petitions_format_number($petition->getReviewTimeframe()), $message['body'][0]);
      }
      else {
        unset($message);
      }

      break;

    case 'review_threshold_passed':
      $langcode = $message['language']->language;
      $message['subject'] = variable_get('wh_petitions_review_threshold_passed_subject', '');
      $message['body'][] = variable_get('wh_petitions_review_threshold_passed_text', '');

      $petition  = (array) $params['petition'];
      if (!empty($petition)) {
        if (petitions_data_mongo_reads_are_enabled()) {
          // This section should be removed as part of mongo2mysql cleanup.

          $legacy_id = check_plain($petition['_id']);

          if (function_exists('petitionevents_mail_additions')) {
            $context = array();
            $context["petition_title"] = $petition['title'];
            $context["petition_uid"] = $petition['_uid'];
            $context["legacy_id"] = $legacy_id;

            // Mongo2MySql code that can eventually be removed.
            $is_mysql_enabled = petitions_data_mysql_writes_are_enabled();

            if ($is_mysql_enabled) {
              $context["nid"] = petition_get_nid($legacy_id);
            }

            $message_body = $message['body'][0];
            petitionevents_mail_additions($message_body, $context);
            $message['body'][0] = $message_body;
          }

          $message['body'][0] = str_replace('!petition_id', check_plain($legacy_id), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_edit_link', variable_get('petitions_edit_url', $base_url) . '/admin/petitions/' . check_plain($petition['_id']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_title', check_plain($petition['title']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_body', check_plain($petition['body']), $message['body'][0]);

          $link_path = "$base_url/admin/petitions/$legacy_id";
          $link = l($link_path, $link_path);
          $message['body'][0] = str_replace('!petition_remove_link', $link, $message['body'][0]);
        }
        else {
          // Data was read from MySQL, so we have a petition node.
          $nid = check_plain($petition['nid']);
          $legacy_id = (isset($petition['field_legacy_id'][$petition['language']][0]['value']) ? check_plain($petition['field_legacy_id'][$petition['language']][0]['value']) : '');

          if (function_exists('petitionevents_mail_additions')) {
            $context = array();
            $context["petition_title"] = $petition['title'];
            $context["petition_uid"] = $petition['uid'];
            $context["legacy_id"] = $legacy_id;
            $context["nid"] = $nid;

            $message_body = $message['body'][0];
            petitionevents_mail_additions($message_body, $context);
            $message['body'][0] = $message_body;
          }

          $message['body'][0] = str_replace('!petition_id', $nid, $message['body'][0]);
          $message['body'][0] = str_replace('!petition_edit_link', variable_get('petitions_edit_url', $base_url) . '/node/' . $nid . '/edit', $message['body'][0]);
          $message['body'][0] = str_replace('!petition_title', check_plain($petition['title']), $message['body'][0]);
          $message['body'][0] = str_replace('!petition_body', check_plain($petition['body'][$petition['language']][0]['value']), $message['body'][0]);

          // Replacement for petition_remove_link.
          $link_path = petitionadmin_get_admin_url($nid);
          $link = l($link_path, $link_path);
          $message['body'][0] = str_replace('!petition_remove_link', $link, $message['body'][0]);
        }
      }
      else {
        unset($message);
      }
      break;

    case 'status_change':
      $legacy_id = $params['petition']['_id'];
      if ($params['petition']['petition_status'] == 6) {
        $message['subject'] = t('Petition Removal');
        $message['body'][] = t('Petition @title (@id), has been removed by @remover',
          array(
            '@title' => $params['petition']['title'],
            '@id' => $params['petition']['_id'],
            '@remover' => $params['remover'],
          )
        );
        $message['body'][] = t("The creator's email is @mail",
          array(
            '@mail' => $params['creator_email'],
          )
        );
        break;

      }

      // We're only sending mail for removals, so don't do anything else.
      return FALSE;
  }

  $message['body'][0] = str_replace('!baseurl', check_plain($base_url), $message['body'][0]);
}

/**
 * Custom access callback for petition nodes.
 *
 * @param string $op
 *   Operation to be checked, one of view, update, delete, create
 * @param mixed $node
 *   Either the node to perform the operation on or the node type to create.
 * @param null $account
 *   User account to check permission for
 *
 * @return bool
 *   Return TRUE if user should have access, call node_access() if it
 *   isn't a a petition node or an operation we don't care about.
 */
function wh_petitions_petition_access($op, $node, $account = NULL) {
  if (is_object($node) && $node->type != 'petition') {
    return node_access($op, $node, $account);
  }

  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $petition_status = is_object($node) ? $node->field_petition_status[LANGUAGE_NONE][0]['value'] : NULL;

  switch ($op) {
    case 'view':
      // Allow super-admin to view petitions in any status, but only published for regular admins.
      if ($account->uid != 1) {
        if ($petition_status == WH_PETITION_STATUS_DRAFT) {
          return FALSE;
        }
      }
      break;

    case 'update':
    case 'delete':
      // Allow only user 1 to access these operations.
      return $account->uid == 1;
      break;

    case 'create':
      // Force everyone to use the /petition/create workflow.
      if ($node == 'petition') {
        return FALSE;
      }
    break;
  }

  // If nothing matched, fall through to the default access callback.
  return node_access($op, $node, $account);

}

/**
 * Custom user access callback function for wh_petitions module.
 *
 * @param string $string
 *   Permission string to check.
 * @param mixed $account
 *   Account object to check permission, defaults to NULL.
 *
 * @return bool
 *   Returns TRUE if user represented by $account has this permission.
 */
function _wh_petitions_user_access($string, $account = NULL) {

  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  if ($account->uid == 1) {
    return TRUE;
  }
  // Sanity check to make sure this is the one permission we are interested in.
  if ($string == 'access devel information') {
    return FALSE;
  }

  // Return core user_access() on the odd chance we get here.
  return user_access($string, $account);
}

/**************** MONGO HELPER FUNCTIONS ******************/

/**
 * Creates a connection to the petitions collection.
 */
function wh_petitions_mongo_petition_connection() {
  try {
    $collection = mongodb_collection('petitions');
  }
  catch (Exception $e) {
    logger_event('exception.wh_petitions.0ba11dd');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_petition_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Creates a connection to the archive_petitions collection.
 */
function wh_petitions_mongo_archive_petition_connection() {
  try {
    $collection = mongodb_collection('archive_petitions');
  }
  catch (Exception $e) {
    logger_event('exception.wh_petitions.d918789');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_archive_petition_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Creates a connection to the petition signatures collection.
 */
function wh_petitions_mongo_petition_signatures_connection() {
  try {
    $collection = mongodb_collection('petition_signatures');
  }
  catch (Exception $e) {
    logger_event('exception.wh_petitions.1616017');
  }

  if (!petitions_data_mongo_reads_are_enabled()) {
    $backtrace = debug_backtrace();
    $calling_func = '';
    if (count($backtrace) > 1) {
      $calling_func = $backtrace[1]['function'];
    }
    watchdog('petition', 'wh_petitions_mongo_petition_signatures_connection() called. Calling Function: @calling_func', array(
      '@calling_func' => $calling_func,
    ), WATCHDOG_WARNING);
  }
  return $collection;
}

/**
 * Saves a petition object to the petitions collection.
 *
 * Saves a petition object to the petitions collection.  It's more
 * efficient to use the $set operator unless there are major changes
 * or this is the first save.
 */
function wh_petitions_save_petition(&$collection, $petition) {
  if (!empty($petition) && !empty($collection)) {
    // Explicitly cast the uid as an integer.
    $petition['uid'] = (int) $petition['uid'];
    if ($petition['created'] == 0) {
      $petition['created'] = (int) time();
      logger_event('petition.created');
    }
    $collection->save($petition);
    petitions_data_freshen_cached_petition($petition['_id']);

    return $petition['_id']->__toString();
  }
}

/**
 * Saves a signature object to the petition_signatures collection.
 *
 * @todo: Fix the return. For a new object, there is no _id value.
 */
function wh_petitions_save_signature($signature, $collection = '') {
  if (empty($collection)) {
    $collection = wh_petitions_mongo_petition_signatures_connection();
  }
  if (!empty($signature) && !empty($collection)) {
    $collection->save($signature);
    module_invoke_all('wh_petitions_signature_save', $signature, $collection);

    return $signature['_id']->__toString();
  }
}

/**
 * Deletes a petition object.
 *
 * Saves it to the archive_petition collection, removes from
 * petition collection.
 */
function wh_petitions_delete_petition(&$collection, $petition_id) {
  global $user;

  if (!empty($petition_id) && !empty($collection)) {
    $archive = wh_petitions_mongo_archive_petition_connection();
    $petition = array();
    $petition = wh_petitions_load_petition($collection, $petition_id);
    if (!empty($petition) && $user->uid == $petition['uid'] && $petition['petition_status'] == WH_PETITION_STATUS_DRAFT) {
      if ($archive->save($petition)) {
        // We successfully saved petition to archive, can now safely remove it.
        $collection->remove(array('_id' => new MongoId($petition_id)));

        return TRUE;
      }
    }
  }
  petitions_data_freshen_cached_petition($petition_id);

  return FALSE;
}

/**
 * Gets a petition id from a nice url.
 *
 * @param MongoClient $collection
 *   The resource of the MongoDB collection to query against.
 */
function wh_petitions_get_petition_id(&$collection) {
  if (!empty($collection)) {
    $petition_id = '';
    $petition = $collection->findOne(array('nice_url' => 'petition/' . arg(1)), array('title'));
    if (!empty($petition)) {
      return $petition['_id']->__toString();
    }
  }

  return '';
}

/**
 * Gets petition id from nice url.
 *
 * @param str $url
 *   The url to validate against.
 */
function wh_petitions_get_petition_id_by_url($url) {
  if (petitions_data_mongo_reads_are_enabled()) {
    return wh_petitions_get_petition_id(wh_petitions_mongo_petition_connection());
  }
  else {
    $query = db_select('node', 'n');
    $query->addJoin('url_alias', 'ua', 'substring(ua.source, 6) = n.nid');
    $query->addField('n', 'nid');
    $query->condition('ua.alias', db_like($url), 'LIKE');
    $result = $query->execute()->fetchAssoc();
    return $result['nid'];
  }

  return '';
}
/**
 * Check to see if signature exists already.
 *
 * @param string $petition_id
 *   The unique identifier of the petition.
 * @param int $uid
 *   A user ID.
 *
 * @return string|false
 *   Signature ID or FALSE if it doesn't exist yet.
 */
function wh_petitions_get_signature_id($petition_id, $uid) {
  $signature_id = FALSE;

  // Create connection.
  $sig_connection = wh_petitions_mongo_petition_signatures_connection();
  $sig_connection->setSlaveOkay(FALSE);

  // Determine if this user has already signed the petition.
  $query = array(
    'uid' => (int) $uid,
    'petition_id' => (string) $petition_id,
  );
  $result = $sig_connection->findOne($query);
  if (!empty($result)) {
    $signature_id = $result['_id']->__toString();
    // TODO make sure this ^^ works.
  }

  return $signature_id;
}


/**
 * Loads the minimum number of fields from the petition object.
 *
 * Loads the minimum number of fields from the petition object.
 * Use this instead of load_petition when we don't need access
 * to all ( or a majority ) of fields.
 *
 * @param MongoClient $collection
 *   The resource of the MongoDB collection to query against.
 * @param string $petition_id
 *   The unique identifier of the requested petition
 * @param array $extra_fields
 *   Fields that will be added into the query and returned.
 */
function wh_petitions_load_slim_petition(&$collection, $petition_id, $extra_fields = array()) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $retrieve_fields = array('title', 'nice_url', 'short_url');
    $retrieve_fields = array_merge($retrieve_fields, $extra_fields);

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id), $retrieve_fields);
    return $petition;
  }

  return array();
}

/**
 * Loads a petition object and merges it with the default petition.
 */
function wh_petitions_load_petition(&$collection, $petition_id, $extra_fields = array()) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id));

    if (!empty($petition)) {
      // Merge default object with one retrieved to pick up any new fields.
      $default = wh_petitions_default_petition();

      // Note: Fields with the same string keys from later arrays
      // override those from earlier arrays.
      $petition = array_merge($default, $petition);
      return $petition;
    }
  }

  return array();
}

/**
 * Gets a petition title.
 */
function wh_petitions_load_petition_title(&$collection, $petition_id) {
  if (!empty($petition_id) && !empty($collection)) {
    // Convert to a Mongo ID if we got a string.
    if (!is_object($petition_id)) {
      $petition_id = new MongoId($petition_id);
    }

    $petition = array();
    $petition = $collection->findOne(array('_id' => $petition_id), array('title'));
    return $petition['title'];
  }
}

/**
 * Generate a nice url for this petition using pathauto URL cleaning.
 *
 * @param array $petition
 *   Petition result array.
 */
function wh_petitions_generate_nice_url(&$petition) {
  $pattern = variable_get('wh_petitions_nice_url_pattern', WH_PETITION_NICE_URL);

  // Generate path using the pathauto configuration.
  module_load_include('inc', 'pathauto');
  $alias = token_replace($pattern, array('petition' => $petition), array(
    'clear' => TRUE,
    'callback' => 'pathauto_clean_token_values',
  )) . '/' . wh_petitions_generate_hash(8);

  if (_wh_petitions_nice_url_exists($alias, $petition)) {
    $separator = variable_get('pathauto_separator', '-');
    $original_alias = $alias;

    $i = 0;
    do {
      // Append an incrementing numeric suffix until we find a unique alias.
      $alias = $original_alias . $separator . $i;
      $i++;
    } while (_wh_petitions_nice_url_exists($alias, $petition));
  }

  $petition['nice_url'] = $alias;
}


/**
 * Check to see if the same alias exists for a different Petition.
 */
function _wh_petitions_nice_url_exists($alias, $petition) {
  $collection = wh_petitions_mongo_petition_connection();

  $query = array('nice_url' => $alias);
  if (isset($petition['_id'])) {
    $query['_id'] = array('$ne' => $petition['_id']);
  }

  $petitions = $collection->find($query);
  return $petitions->count() > 0;
}

/**
 * Generate a short url for this petition.
 */
function wh_petitions_generate_short_url(&$petition) {
  if (empty($petition['nice_url'])) {
    wh_petitions_generate_nice_url($petition);
  }
  $petition['short_url'] = wh_petition_tool_shortenurl($petition['nice_url']);
}

/**
 * Returns a default petition object.
 */
function wh_petitions_default_petition() {
  $petition = array(
    // Drupal UID of the creator.
    'uid'               => 0,

    // Display title of the petition.
    'title'             => '',

    // Array of words from the title for searching.
    'title_keywords'    => array(),

    // The body/description of the petition.
    'body'              => '',

    // Array of words from the body for searching.
    'body_keywords'     => array(),

    // Array of previous petition object ids;
    // only admins can edit a non-draft petition.
    'body_revisions'    => array(),

    // Array of petition types.
    'petition_type'     => array(),

    // Array of taxonomy term IDs.
    'issues'            => array(),

    // Array of taxonomy term IDs for user-submitted keywords.
    'user_tags'         => array(),

    // Array of taxonomy term IDs for private admin-added keywords.
    'private_tags'      => array(),

    // Array of Mongo IDs of related petitions.
    'related_petitions' => array(),

    // State of the petition: public, private, in review, reviewed.
    'petition_status'   => 0,

    // State of the response: none, presidential, etc.
    'response_status'   => 0,

    // Timestamp for when this petition was published.
    'published'         => 0,

    // Timestamp for when this petition reached 'make-public' threshold.
    'reached_public'    => 0,

    // Timestamp for when this petition reached review threshold.
    'reached_ready'     => 0,

    // Timestamp for when this petition was responded to.
    'closed'            => 0,

    // Count of signatures.
    'signature_count'   => 0,

    // Drupal UIDs of people who have flagged this as abuse.
    'abuse_flags'       => array(),

    // Number of days a petition has to reach X signatures and receive a review.
    'review_timeframe'  => 0,

    // Number of signatures required to receive a response.
    'response_signatures' => 0,

    // Number of signatures needed to become public.
    'public_signatures' => 0,

    // Array of Drupal UID's of people who have bookmarked this.
    'bookmarked'        => array(),

    // Whether this is a featured petition ( 0 or 1 ).
    'featured'          => 0,

    // Whether this petition has been removed from lists.
    'hidden'            => 0,

    // Nice url to display the petition detail page at.
    'nice_url'          => '',

    // WH.gov shorturl.
    'short_url'         => '',

    // Timestamp for when petition was created.
    'created'           => 0,
  );

  return $petition;
}

/**
 * Log admin activity (removing/re-enabling) on petitions or signatures.
 *
 * @param object $acting_user
 *   The drupal user object of the admin
 * @param string $entity_type
 *   String of type of entity
 * @param object $entity_acted_upon
 *   the petition or signature object the admin acted upon
 *
 * @return Int
 *   Mongo id of log entry
 */
function wh_petitions_admin_log($acting_user, $entity_type, $entity_acted_upon) {
  // Get collection.
  try {
    $collection = mongodb_collection('admin_log');
  }
  catch (Exception $e) {
    logger_event('exception.wh_petitions.3bc99b3');
  }

  switch ($entity_type) {
    case 'petition':
      $status = $entity_acted_upon['petition_status'];
      break;

    case 'petition_signature':
      $status = $entity_acted_upon['status'];
      break;

    default:
      $status = $entity_acted_upon['status'];
      watchdog('WH Petitions', 'Unknown entity_type (%type) in !file::!line',
        array(
          '%type' => $entity_type,
          '!file' => __FILE__,
          '!line' => __LINE__,
        )
      );
  }

  // Build log entry.
  $entry = array(
    'uid'         => $acting_user->uid,
    'timestamp'   => time(),
    'entity_type' => $entity_type,
    'entity_id'   => $entity_acted_upon['_id'],
    'status'      => $status,
  );

  $collection->save($entry);

  return $entry['_id']->__toString();
}

/**
 * Invoke petition signature observer.
 *
 * Wrapper for invoking all the functionality that needs to be triggered
 * when a petition is signed.
 *
 * @param int $petition_id
 *   The id of the petition being signed.
 * @param int $user_id
 *   The id of the user signing the petition.
 * @param string $ip_address
 *   (optional) The IP address from which the user is signing the petition.
 * @param string $user_agent
 *   (optional) The user agent string of the signer's browser.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise
 */
function wh_petitions_sign_petition($petition_id, $user_id, $ip_address = '', $user_agent = '') {

  // Setup connections for signatures and petitions.
  $connection = wh_petitions_mongo_petition_connection();
  $connection->setSlaveOkay(FALSE);
  $sig_connection = wh_petitions_mongo_petition_signatures_connection();
  $sig_connection->setSlaveOkay(FALSE);

  $slim_petition_elements = array(
    'petition_status',
    'signature_count',
    'response_signatures',
    'public_signatures',
  );

  // Load the petition.
  $petition = wh_petitions_load_slim_petition($connection, $petition_id, $slim_petition_elements);

  // If it wasn't a valid petition id, exit.
  if (empty($petition)) {
    return FALSE;
  }

  // Load user.
  $user = user_load($user_id);

  if (!wh_petitions_create_signature($petition, $user, $sig_connection, $ip_address, $user_agent)) {
    watchdog('wh_petitions', 'Failed to create signature for @user on @petition', array('@user' => $user->uid, '@petition' => $petition['_id']));
    return FALSE;
  };

  // Up the signature_count on the petition.
  wh_petitions_increment_signature_count($petition, $connection);
}

/**
 * Create and save a signature object for the given user and petition.
 *
 * @param object $petition
 *   The petition object being signed.
 * @param object $user
 *   The user object signing the petition.
 * @param MongoClient $signature_collection_connection
 *   Connection to be used for querying and storing the signature.
 * @param string $ip_address
 *   (optional) The IP address from which the user is signing the petition.
 * @param string $user_agent
 *   (optional) The user agent string of the signer's browser.
 * @param int $timestamp
 *   Time when signature was signed. If FALSE, defaults to time().
 *
 * @return string
 *   ID of created signature or FALSE on failure.
 */
function wh_petitions_create_signature($petition, $user, $signature_collection_connection, $ip_address = '', $user_agent = '', $timestamp = FALSE) {
  // Check if signature_id exists.
  if ($signature_id = wh_petitions_get_signature_id($petition['_id'], $user->uid)) {
    watchdog('wh_petitions', 'unable to create signature, user @user has already signed @petition', array('@petition' => $petition['_id'], '@user' => $user->uid));
    return FALSE;
  }

  // Load the profile for this user
  // @todo: refactor this to not bomb if profile2 isn't installed.
  $profile = profile2_load_by_user($user);
  $fields = array('first_name', 'last_name', 'city', 'state', 'zip', 'country');
  $user_fields = array();
  foreach ($fields as $f) {
    if (!empty($profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'])) {
      $user_fields[$f] = $profile['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'];
    }
  }

  // Sign the petition without a comment.
  $signature_count = $petition['signature_count'] + 1;
  $signature = array(
    'petition_id' => (string) $petition['_id'],
    'timestamp'   => ($timestamp) ? $timestamp : (int) time(),
    'ip_address'  => (string) $ip_address,
    'user_agent'  => (string) $user_agent,
    'comment'     => '',
    'uid'         => (int) $user->uid,
    'abuse_flags' => array(),
    'status'      => 1,
    'number'      => $signature_count,
    'user'        => array_merge($user_fields, array('username' => $user->name)),
  );

  return wh_petitions_save_signature($signature);
}

/**
 * Increment signature_count of a petition.
 *
 * Increment the signature_count of a petition and check to see
 * if has passed any milestones.
 *
 * @param array $petition
 *   The petition object which will will be incremented
 * @param MongoClient $connection
 *   A connection to the petition dataset
 */
function wh_petitions_increment_signature_count(&$petition, $connection = FALSE) {
  $connection->update(
    array('_id' => $petition['_id']),
    array('$inc' => array('signature_count' => 1))
  );

  $slim_petition_elements = array(
    'petition_status',
    'signature_count',
    'response_signatures',
    'public_signatures',
    'uid',
  );

  $petition = wh_petitions_load_slim_petition($connection, $petition['_id'], $slim_petition_elements);

  // Update to public petition.
  $reached_response = FALSE;
  if ($petition['petition_status'] == WH_PETITION_STATUS_PRIVATE && $petition['signature_count'] == $petition['public_signatures']) {
    $connection->update(
      array('_id' => $petition['_id']),
      array('$set' => array('petition_status' => (int) WH_PETITION_STATUS_PUBLIC, 'reached_public' => (int) time()))
    );
  }
  // Record the time the petition became eligible for a response.
  elseif ($petition['petition_status'] == WH_PETITION_STATUS_PUBLIC && $petition['signature_count'] == $petition['response_signatures']) {
    $connection->update(
      array('_id' => $petition['_id']),
      array(
        '$set' => array(
          'petition_status' => (int) WH_PETITION_STATUS_UNDER_REVIEW,
          'response_status' => (int) WH_PETITION_RESPONSE_STATUS_PENDING,
          'reached_ready' => (int) time(),
        ),
      )
    );
    $reached_response = TRUE;
  }

  // Email the creator if the petition is ready for a response.
  if ($reached_response && petitions_data_mongo_reads_are_enabled()) {
    wh_petitions_email_ready_response($petition['_id']->__toString(), $petition['uid']);
  }

  // Reload petition object.
  $petition = wh_petitions_load_slim_petition($connection, $petition['_id'], $slim_petition_elements);
}

/**
 * Unpublish a single node from Mongo.
 *
 * @param int $legacy_id
 *   ID identifier from MongoDB.
 */
function wh_petitions_mongo2mysql_hide($legacy_id) {
  global $user;
  $petition = NULL;
  if (!empty($legacy_id)) {
    $conn = wh_petitions_mongo_petition_connection();
    $petition = wh_petitions_load_petition($conn, $legacy_id);
    $petition['petition_status'] = WH_PETITION_STATUS_FLAGGED;

    wh_petitions_save_petition($conn, $petition);
    // Log the activity to the admin_log collection.
    wh_petitions_admin_log($user, 'petition', $petition);
  }

  return $petition;
}

/**
 * Publish a single node from Mongo.
 *
 * @param int $legacy_id
 *   ID identifier from MongoDB.
 */
function wh_petitions_mongo2mysql_show($legacy_id) {
  global $user;
  $petition = NULL;

  if (!empty($legacy_id)) {
    $conn = wh_petitions_mongo_petition_connection();
    $petition = wh_petitions_load_petition($conn, $legacy_id);

    // Check to see what Status it should have.
    $timestamp = strtotime('- ' . $petition['review_timeframe'] . ' days');

    if ($petition['published'] < $timestamp) {
      $petition['petition_status'] = WH_PETITION_STATUS_CLOSED;
    }
    elseif ($petition['signature_count'] < $petition['public_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_PRIVATE;
    }
    elseif ($petition['signature_count'] < $petition['response_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_PUBLIC;
    }
    elseif ($petition['signature_count'] >= $petition['response_signatures']) {
      $petition['petition_status'] = WH_PETITION_STATUS_UNDER_REVIEW;
      $petition['response_status'] = WH_PETITION_RESPONSE_STATUS_PENDING;
    }

    wh_petitions_save_petition($conn, $petition);
    $text = t('Hide from Site');

    // Log the activity to the admin_log collection.
    wh_petitions_admin_log($user, 'petition', $petition);
  }

  return $petition;
}

/**
 * Implements hook_admin_paths().
 */
function wh_petitions_admin_paths() {
  $paths = array(
    'remove-mongo-petition' => TRUE,
  );
  return $paths;
}

/**
 * Generates share links for petitions, including Facebook, Twitter and Email.
 *
 * @param array $vars
 *   Passes $node object only.
 *
 * @return array
 *   Render array of the share links.
 */
function theme_petitions_share_links($vars) {
  if(empty($vars['node'])) return array();

  $node = $vars['node'];
  $title = check_plain($node->title);
  $nid = $node->nid;
  $lang = $node->language;
  $url = drupal_get_path_alias('node/' . $nid);
  $short_url = empty($node->field_short_url[$lang][0]['value']) ? '' : $node->field_short_url[$lang][0]['value'];

  $share_links = array(
    'share_links' => array(
      'facebook_link' => array(
        '#markup' => wh_petition_tool_facebook_link($nid, check_plain($title), 'petition', '', $url),
      ),
      array('#markup' => '&nbsp;'),
      'email_link' => array(
        '#markup' => wh_petition_tool_email_link(
          t('Email'),
          t('Will you add your name to this petition?'),
          t("I wanted to let you know about a We the People petition and ask for your support. Will you add your name to mine? If this petition gets 100,000 signatures within 30 days of its creation, the White House will review it and respond!\r\rYou can view and sign the petition here:\r\r@title\r@path\r\rThanks for raising your voice!",
            array(
              '@title' => check_plain($title),
              '@path' => url(
                $url,
                array('absolute' => TRUE)
              ),
            )
          )
        ),
      ),
      array('#markup' => '&nbsp;'),
      'twitter_link' => array(
        '#markup' => wh_petition_tool_twitter_link($nid, check_plain($title), 'petition', '', $short_url, $url),
      ),
    ),
  );

  return $share_links;
}


/**
 * Add column divs to checkbox/radio elements.
 *
 * @param array $element
 *   Form element.

 * @return string
 *   Rendered output.
 */
function theme_multicolumn_options($element) {
  $stripped_element = array_values($element);
  $element = $stripped_element[0];

// Initialize variables.
  $output = '';
  $total_columns = $element['#multicolumn_numcols'];
  $total_options = count($element['#options']);
  $options_per_column = ceil($total_options / $total_columns);
  $keys = array_keys($element['#options']);

  // Start wrapper div.
  $output .= '<div class="multicolumn-options-wrapper">';
  $current_column = 1;
  $current_option = 0;

  while ($current_column <= $total_columns) {
    // Start column div.
    $output .= '<div class="multicolumn-options-column">';

    // Keep looping through until the maximum options per column are reached,
    // or you run out of options.
    while ($current_option < $options_per_column * $current_column &&
      $current_option < $total_options) {

      // Output as either check or radio button depending on the element type.
      $output .= drupal_render($element[$keys[$current_option]]);
      $current_option++;
    }

    // End column div.
    $output .= '</div>';
    $current_column++;
  }

  // End wrapper div.
  $output .= '</div>';

  return $output;
}

/**
 * Default theme implementation for petition_preface.
 */
function theme_petition_preface($variables) {
  $preface = '';

  if (isset($variables['node']) && $variables['node']->type == 'petition') {
    if ($field_petition_type = field_get_items('node', $variables['node'], 'field_petition_type')) {
      $term = taxonomy_term_load($field_petition_type[0]['tid']);
      $petition_type = $term->name;

      $preface = array(
        '#theme' => 'html_tag',
        '#tag' => 'h6',
        '#value' => t('We the people ask the federal government to @type:', array('@type' => $petition_type)),
        '#attributes' => array(
          'class' => array('petition-preface'),
        )
      );
    }
  }

  return $preface;
}

/**
 * Default theme implementation for petition_attribution.
 */
function theme_petition_attribution($variables) {
  if (isset($variables['node'])) {
    $creator_initials = _wh_petitions_creator_initials($variables['node']);
    $date_published = _wh_petitions_date_published($variables['node']);

    $attribution = array(
      '#theme' => 'html_tag',
      '#tag' => 'h4',
      '#value' => t('Created @initials on @date', array(
          '@initials' => $creator_initials,
          '@date' => $date_published
        )),
      '#attributes' => array(
        'class' => array('petition-attribution'),
      )
    );

    return $attribution;
  }
}

/**
 * Get the first and last initials of a node's author.
 *
 * @param $node
 *   A node object
 *
 * @return FALSE|string
 *   First and last initials, or false if unavailable.
 */
function _wh_petitions_creator_initials($node) {
  if($user = profile2_load_by_user($node->uid)){
    $user_fields = array();
    $fields = array('first_name', 'last_name');
    foreach ($fields as $f) {
      if (!empty($user['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'])) {
        $user_fields[$f] = $user['main']->{'field_' . $f}[LANGUAGE_NONE][0]['value'];
      }
    }
    $first_initial = isset($user_fields['first_name']) ? strtoupper($user_fields['first_name'][0]) : FALSE;
    $last_initial = isset($user_fields['last_name']) ? strtoupper($user_fields['last_name'][0]) : FALSE;
    $creator_initials = ($first_initial && $last_initial) ? "by {$first_initial}.{$last_initial}." : FALSE;

    return $creator_initials;
  }

  return false;
}

/**
 * Retrieve and format a node's published date.
 *
 * @param obj $node
 *   A Drupal node object.
 *
 * @return string
 */
function _wh_petitions_date_published($node) {
  if($date = $node->field_timestamp_published[LANGUAGE_NONE][0]['value']){
    return date("F d, Y", $date);
  };
}

/**
 * Implements hook_form_alter().
 */
function wh_petitions_form_alter(&$form, &$form_state, $form_id) {
  $form['#validate'][] = '_wh_petitions_add_field_error_labels';
}

/**
 * Implements hook_petition_signatures_updated().
 */
function wh_petitions_petition_signatures_updated($nid) {
  _wh_petitions_compliance_review_threshold_check_node($nid);
}
